<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Pcre class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3-rc3 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>Pcre Class Reference</h1><code>#include &lt;<a class="el" href="pcre++_8h-source.html">pcre++.h</a>&gt;</code>
<p>
<a href="classPcre-members.html">List of all members.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Public Member Functions</h2></td></tr>
<tr><td nowrap align=right valign=top>&nbsp;</td><td valign=bottom><a class="el" href="classPcre.html#a0">Pcre</a> ()</td></tr>
<tr><td nowrap align=right valign=top>&nbsp;</td><td valign=bottom><a class="el" href="classPcre.html#a1">Pcre</a> (const std::string &amp;expression)</td></tr>
<tr><td nowrap align=right valign=top>&nbsp;</td><td valign=bottom><a class="el" href="classPcre.html#a2">Pcre</a> (const std::string &amp;expression, const std::string &amp;flags)</td></tr>
<tr><td nowrap align=right valign=top>&nbsp;</td><td valign=bottom><a class="el" href="classPcre.html#a3">Pcre</a> (const Pcre &amp;P)</td></tr>
<tr><td nowrap align=right valign=top>const Pcre &amp;&nbsp;</td><td valign=bottom><a class="el" href="classPcre.html#a4">operator=</a> (const std::string &amp;expression)</td></tr>
<tr><td nowrap align=right valign=top>const Pcre &amp;&nbsp;</td><td valign=bottom><a class="el" href="classPcre.html#a5">operator=</a> (const Pcre &amp;P)</td></tr>
<tr><td nowrap align=right valign=top>&nbsp;</td><td valign=bottom><a class="el" href="classPcre.html#a6">~Pcre</a> ()</td></tr>
<tr><td nowrap align=right valign=top>bool&nbsp;</td><td valign=bottom><a class="el" href="classPcre.html#a7">search</a> (const std::string &amp;stuff)</td></tr>
<tr><td nowrap align=right valign=top>bool&nbsp;</td><td valign=bottom><a class="el" href="classPcre.html#a8">search</a> (const std::string &amp;stuff, int OffSet)</td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="pcre++_8h.html#a1">Array</a> *&nbsp;</td><td valign=bottom><a class="el" href="classPcre.html#a9">get_sub_strings</a> ()</td></tr>
<tr><td nowrap align=right valign=top>std::string&nbsp;</td><td valign=bottom><a class="el" href="classPcre.html#a10">get_match</a> (int pos)</td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classPcre.html#a11">get_match_start</a> (int pos)</td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classPcre.html#a12">get_match_end</a> (int pos)</td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classPcre.html#a13">get_match_start</a> ()</td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classPcre.html#a14">get_match_end</a> ()</td></tr>
<tr><td nowrap align=right valign=top>size_t&nbsp;</td><td valign=bottom><a class="el" href="classPcre.html#a15">get_match_length</a> (int pos)</td></tr>
<tr><td nowrap align=right valign=top>bool&nbsp;</td><td valign=bottom><a class="el" href="classPcre.html#a16">matched</a> ()</td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classPcre.html#a17">matches</a> ()</td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="pcre++_8h.html#a1">Array</a>&nbsp;</td><td valign=bottom><a class="el" href="classPcre.html#a18">split</a> (const std::string &amp;piece)</td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="pcre++_8h.html#a1">Array</a>&nbsp;</td><td valign=bottom><a class="el" href="classPcre.html#a19">split</a> (const std::string &amp;piece, int limit)</td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="pcre++_8h.html#a1">Array</a>&nbsp;</td><td valign=bottom><a class="el" href="classPcre.html#a20">split</a> (const std::string &amp;piece, int limit, int start_offset)</td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="pcre++_8h.html#a1">Array</a>&nbsp;</td><td valign=bottom><a class="el" href="classPcre.html#a21">split</a> (const std::string &amp;piece, int limit, int start_offset, int end_offset)</td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="pcre++_8h.html#a1">Array</a>&nbsp;</td><td valign=bottom><a class="el" href="classPcre.html#a22">split</a> (const std::string &amp;piece, std::vector&lt; int &gt; positions)</td></tr>
<tr><td nowrap align=right valign=top>std::string&nbsp;</td><td valign=bottom><a class="el" href="classPcre.html#a23">replace</a> (const std::string &amp;piece, const std::string &amp;with)</td></tr>
<tr><td colspan=2><br><h2>Public Attributes</h2></td></tr>
<tr><td nowrap align=right valign=top>bool&nbsp;</td><td valign=bottom><a class="el" href="classPcre.html#m0">did_match</a></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classPcre.html#m1">num_matches</a></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
The Pcre class is a wrapper around the PCRE library.<p>
The library "pcre++" defines a class named "Pcre" which you can use to search in strings using reular expressions as well as getting matched sub strings. It does currently not support all features, which the underlying PCRE library provides, but the most important stuff is implemented.<p>
Please study this example code to learn how to use this class: <div class="fragment"><pre><span class="comment">/*</span>
<span class="comment"> *</span>
<span class="comment"> *  This file  is part of the PCRE++ Class Library.</span>
<span class="comment"> *</span>
<span class="comment"> *  By  accessing  this software,  PCRE++, you  are  duly informed</span>
<span class="comment"> *  of and agree to be  bound  by the  conditions  described below</span>
<span class="comment"> *  in this notice:</span>
<span class="comment"> *</span>
<span class="comment"> *  This software product,  PCRE++,  is developed by Thomas Linden</span>
<span class="comment"> *  and  copyrighted (C) 2002  by  Thomas Linden,  with all rights </span>
<span class="comment"> *  reserved.</span>
<span class="comment"> *</span>
<span class="comment"> *  There  is no charge for PCRE++ software.  You can redistribute</span>
<span class="comment"> *  it and/or modify it under the terms of the GNU  Lesser General</span>
<span class="comment"> *  Public License, which is incorporated by reference herein.</span>
<span class="comment"> *</span>
<span class="comment"> *  PCRE++ is distributed WITHOUT ANY WARRANTY, IMPLIED OR EXPRESS,</span>
<span class="comment"> *  OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE or that</span>
<span class="comment"> *  the use of it will not infringe on any third party's intellec-</span>
<span class="comment"> *  tual property rights.</span>
<span class="comment"> *</span>
<span class="comment"> *  You should have received a copy of the GNU Lesser General Public</span>
<span class="comment"> *  License along with PCRE++.  Copies can also be obtained from:</span>
<span class="comment"> *</span>
<span class="comment"> *    http://www.gnu.org/licenses/lgpl.txt</span>
<span class="comment"> *</span>
<span class="comment"> *  or by writing to:</span>
<span class="comment"> *</span>
<span class="comment"> *  Free Software Foundation, Inc.</span>
<span class="comment"> *  59 Temple Place, Suite 330</span>
<span class="comment"> *  Boston, MA 02111-1307</span>
<span class="comment"> *  USA</span>
<span class="comment"> *</span>
<span class="comment"> *  Or contact:</span>
<span class="comment"> *</span>
<span class="comment"> *   "Thomas Linden" &lt;tom@daemon.de&gt;</span>
<span class="comment"> *</span>
<span class="comment"> *</span>
<span class="comment"> */</span>


<span class="comment">/* you need to include the pcre++ header file */</span>
<span class="preprocessor">#include &lt;<a class="code" href="pcre++_8h.html">pcre++.h</a>&gt;</span>
<span class="preprocessor">#include &lt;iostream&gt;</span>

<span class="keyword">using</span> <span class="keyword">namespace </span>std;

<span class="keywordtype">void</span> regex() {
    <span class="comment">/*</span>
<span class="comment">     * define a string with a regular expression</span>
<span class="comment">     */</span>
    string expression = <span class="stringliteral">"([a-z]*) ([0-9]+)"</span>;

    <span class="comment">/*</span>
<span class="comment">     * this is the string in which we want to search</span>
<span class="comment">     */</span>
    string stuff = <span class="stringliteral">"hallo 11 robert"</span>;

    cout &lt;&lt; <span class="stringliteral">"  searching in \""</span> &lt;&lt; stuff &lt;&lt; <span class="stringliteral">"\" for regex \""</span>
         &lt;&lt; expression &lt;&lt; <span class="stringliteral">"\":"</span> &lt;&lt; endl;

    <span class="comment">/*</span>
<span class="comment">     * Create a new Pcre object, search case-insensitive ("i")</span>
<span class="comment">     */</span>
    <a class="code" href="classPcre.html">Pcre</a> reg(expression, <span class="stringliteral">"i"</span>);
    
    <span class="comment">/*</span>
<span class="comment">     * see if the expression matched</span>
<span class="comment">     */</span>
    <span class="keywordflow">if</span>(reg.<a class="code" href="classPcre.html#a7">search</a>(stuff) == <span class="keyword">true</span>) {

      <span class="comment">/*</span>
<span class="comment">       * see if the expression generated any substrings</span>
<span class="comment">       */</span>
      <span class="keywordflow">if</span>(reg.<a class="code" href="classPcre.html#m1">num_matches</a> &gt;= 1) {

        <span class="comment">/*</span>
<span class="comment">         * print out the number of substrings</span>
<span class="comment">         */</span>
        cout &lt;&lt; <span class="stringliteral">"  generated "</span> &lt;&lt; reg.<a class="code" href="classPcre.html#a17">matches</a>() &lt;&lt; <span class="stringliteral">" substrings:"</span> &lt;&lt; endl;
          
        <span class="comment">/*</span>
<span class="comment">         * iterate over the matched sub strings</span>
<span class="comment">         */</span>
        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> pos=0; pos &lt; reg.<a class="code" href="classPcre.html#a17">matches</a>(); pos++) {
          <span class="comment">/* print out each substring */</span>
          cout &lt;&lt; <span class="stringliteral">"  substring "</span> &lt;&lt; pos &lt;&lt; <span class="stringliteral">": "</span> &lt;&lt; reg.<a class="code" href="classPcre.html#a10">get_match</a>(pos);
          <span class="comment">/* print out the start/end offset of the current substring</span>
<span class="comment">           * within the searched string(stuff)</span>
<span class="comment">           */</span>
          cout &lt;&lt; <span class="stringliteral">" (start: "</span> &lt;&lt; reg.<a class="code" href="classPcre.html#a11">get_match_start</a>(pos) &lt;&lt; <span class="stringliteral">", end: "</span>
               &lt;&lt; reg.<a class="code" href="classPcre.html#a12">get_match_end</a>(pos) &lt;&lt; <span class="stringliteral">")"</span> &lt;&lt; endl;
        }
      }
      <span class="keywordflow">else</span> {
        <span class="comment">/*</span>
<span class="comment">         * we had a match, but it generated no substrings, for whatever reason</span>
<span class="comment">         */</span>
        cout &lt;&lt; <span class="stringliteral">"   it matched, but there where no substrings."</span> &lt;&lt; endl;
      }
    }
    <span class="keywordflow">else</span> {
      <span class="comment">/*</span>
<span class="comment">       * no match at all</span>
<span class="comment">       */</span>
      cout &lt;&lt; <span class="stringliteral">"   didn't match."</span> &lt;&lt; endl;
    }
}



<span class="keywordtype">void</span> <a class="code" href="classPcre.html#a23">replace</a>() {
    <span class="comment">/*</span>
<span class="comment">     * Sample of replace() usage</span>
<span class="comment">     */</span>
    string orig = <span class="stringliteral">"Hans ist 22 Jahre alt. Er ist 8 Jahre älter als Fred."</span>;
    cout &lt;&lt; <span class="stringliteral">"   orig: "</span> &lt;&lt; orig &lt;&lt; endl;

    <span class="comment">/*</span>
<span class="comment">     * define a regex for digits (character class)</span>
<span class="comment">     */</span>
    <a class="code" href="classPcre.html">Pcre</a> p(<span class="stringliteral">" ([0-9]+) "</span>);

    <span class="comment">/*</span>
<span class="comment">     * replace the 1st occurence of [0-9]+ with "zweiundzwanzig"</span>
<span class="comment">     */</span>
    string n = p.<a class="code" href="classPcre.html#a23">replace</a>(orig, <span class="stringliteral">" zweiundzwanzig($1) "</span>);

    <span class="comment">/*</span>
<span class="comment">     * prints out: "Hans ist zweiundzwanzig Jahre alt. Er ist 8 Jahre älter</span>
<span class="comment">     * als Fred."</span>
<span class="comment">     */</span>
    cout &lt;&lt; <span class="stringliteral">"   new: "</span> &lt;&lt; n &lt;&lt; endl; 
}


<span class="keywordtype">void</span> replace_multi() {
  <span class="comment">/*</span>
<span class="comment">   * Sample of replace() usage with multiple substrings</span>
<span class="comment">   */</span>
  string orig = <span class="stringliteral">" 08:23 "</span>;
  cout &lt;&lt; <span class="stringliteral">"   orig: "</span> &lt;&lt; orig &lt;&lt; endl;
  
  <span class="comment">/*</span>
<span class="comment">   * create regex which, if it matches, creates 3 substrings</span>
<span class="comment">   */</span>
  <a class="code" href="classPcre.html">Pcre</a> reg(<span class="stringliteral">" ([0-9]+)(:)([0-9]+) "</span>, <span class="stringliteral">"sig"</span>);

  <span class="comment">/*</span>
<span class="comment">   * remove $2 (":")</span>
<span class="comment">   * re-use $1 ("08") and $3 ("23") in the replace string</span>
<span class="comment">   */</span>
  string n  = reg.<a class="code" href="classPcre.html#a23">replace</a>(orig, <span class="stringliteral">"$1 Stunden und $3 Minuten"</span>);

  <span class="comment">/*</span>
<span class="comment">   * prints the result: "08 Stunden und 23 Minuten"</span>
<span class="comment">   */</span>
  cout &lt;&lt; <span class="stringliteral">"   new:  "</span> &lt;&lt; n  &lt;&lt; endl;
}


<span class="keywordtype">void</span> normalize() {
  <span class="comment">/*</span>
<span class="comment">   * another sample to check if normalizing using replace() works</span>
<span class="comment">   */</span>
  string orig = <span class="stringliteral">"Heute   ist ein  schoener  Tag        gell?"</span>;
  cout &lt;&lt; <span class="stringliteral">"   orig: "</span> &lt;&lt; orig &lt;&lt; endl;

  <span class="comment">/*</span>
<span class="comment">   * create regex for normalizing whitespace</span>
<span class="comment">   */</span>
  <a class="code" href="classPcre.html">Pcre</a> reg(<span class="stringliteral">"[\\s]+"</span>, <span class="stringliteral">"gs"</span>);

  <span class="comment">/*</span>
<span class="comment">   * do the normalizing process</span>
<span class="comment">   */</span>
  string n = reg.<a class="code" href="classPcre.html#a23">replace</a>(orig, <span class="stringliteral">" "</span>);

  <span class="comment">/*</span>
<span class="comment">   * prints the result, should be: "Heute ist ein schoener Tag , gell?"</span>
<span class="comment">   */</span>
  cout &lt;&lt; <span class="stringliteral">"   new:  "</span> &lt;&lt; n  &lt;&lt; endl;
}


<span class="keywordtype">void</span> <a class="code" href="classPcre.html#a18">split</a>() {
  <span class="comment">/*</span>
<span class="comment">   * Sample of split() usage</span>
<span class="comment">   */</span>
      string sp_orig = <span class="stringliteral">"was21willst2387461du3alter!"</span>;
      cout &lt;&lt; <span class="stringliteral">"   orig: "</span> &lt;&lt; sp_orig &lt;&lt; endl;

      <span class="comment">/*</span>
<span class="comment">       * define a regex for digits (character class)</span>
<span class="comment">       */</span>
      string delimiter = <span class="stringliteral">"[0-9]+"</span>;

      <span class="comment">/*</span>
<span class="comment">       * new Pcre object, match globally ("g" flag)</span>
<span class="comment">       */</span>
      <a class="code" href="classPcre.html">Pcre</a> S(delimiter, <span class="stringliteral">"g"</span>);

      <span class="comment">/*</span>
<span class="comment">       * split "was21willst2387461du3alter!" by digits</span>
<span class="comment">       */</span>
      <a class="code" href="pcre++_8h.html#a1">Array</a> splitted = S.<a class="code" href="classPcre.html#a18">split</a>(sp_orig);
      
      <span class="comment">/*</span>
<span class="comment">       * iterate over the resulting list</span>
<span class="comment">       */</span>
      cout &lt;&lt; <span class="stringliteral">"   splitted: "</span>;
      <span class="keywordflow">for</span>(<a class="code" href="pcre++_8h.html#a2">ArrayIterator</a> A = splitted.begin(); A != splitted.end(); ++A)
        cout &lt;&lt; *A &lt;&lt; <span class="stringliteral">" "</span>;
      cout &lt;&lt; endl;
}


<span class="keywordtype">void</span> ex() {
  <span class="comment">/*</span>
<span class="comment">   * Pcre::exception Test</span>
<span class="comment">   */</span>
  
  <span class="comment">/*</span>
<span class="comment">   * this will generate only one substring, "This"</span>
<span class="comment">   */</span>
  <a class="code" href="classPcre.html">Pcre</a> ex(<span class="stringliteral">"([a-z]+)"</span>, <span class="stringliteral">"i"</span>);
  <span class="keywordflow">if</span>(ex.<a class="code" href="classPcre.html#a7">search</a>(<span class="stringliteral">"This is a test."</span>)) {
    cout &lt;&lt; <span class="stringliteral">"  trying to access a non-existing substring:"</span> &lt;&lt; endl;
    cout &lt;&lt; <span class="stringliteral">"  substring 2: "</span> &lt;&lt; ex.<a class="code" href="classPcre.html#a10">get_match</a>(1) &lt;&lt; endl; 
  }
}


<span class="keywordtype">void</span> mycopy() {
  <span class="comment">/*</span>
<span class="comment">   * Sample use of copy contsructor and operator=</span>
<span class="comment">   */</span>
    cout &lt;&lt; <span class="stringliteral">"  initializing reg1(([a-z]+?)"</span> &lt;&lt; endl;
    <a class="code" href="classPcre.html">Pcre</a> reg1(<span class="stringliteral">"^([a-z]+?)"</span>);

    <span class="comment">/*</span>
<span class="comment">     * create an empty Pcre objects</span>
<span class="comment">     */</span>
    <a class="code" href="classPcre.html">Pcre</a> reg2;
    
    <span class="comment">/*</span>
<span class="comment">     * copy reg1 to reg2 (operator=)</span>
<span class="comment">     */</span>
    cout &lt;&lt; <span class="stringliteral">"  copying reg1 to new Pcre object reg2"</span> &lt;&lt; endl;
    reg2 = reg1;

    <span class="comment">/*</span>
<span class="comment">     * using the copy constructor to initialize the 3rd object</span>
<span class="comment">     */</span>
    cout &lt;&lt; <span class="stringliteral">"  creating a new Pcre object reg3 from reg2"</span> &lt;&lt; endl;
    <a class="code" href="classPcre.html">Pcre</a> reg3(reg2);

    <span class="comment">/*</span>
<span class="comment">     * doing regular stuff on reg3</span>
<span class="comment">     */</span>
    <span class="keywordflow">if</span>(reg3.<a class="code" href="classPcre.html#a7">search</a>(<span class="stringliteral">"anton"</span>))
      cout &lt;&lt; <span class="stringliteral">"  string 'anton' matched using reg3 object"</span> &lt;&lt; endl;
}

<span class="keywordtype">void</span> multisearch() {
  <a class="code" href="classPcre.html">Pcre</a> reg(<span class="stringliteral">"([^\\n]+\\n)"</span>);
  string str = <span class="stringliteral">"\nline1\nline2\nline3\n"</span>;
  size_t pos = 0;

  <span class="keywordflow">while</span> (pos &lt;= str.length()) {
    <span class="keywordflow">if</span>( reg.<a class="code" href="classPcre.html#a7">search</a>(str, pos)) {
      pos = reg.<a class="code" href="classPcre.html#a12">get_match_end</a>(0);
      cout &lt;&lt; <span class="stringliteral">"   pos: "</span> &lt;&lt; pos &lt;&lt; <span class="stringliteral">" match: "</span> &lt;&lt; reg.<a class="code" href="classPcre.html#a10">get_match</a>(0);
    }
    <span class="keywordflow">else</span>
      <span class="keywordflow">break</span>;
  }
}

<span class="keywordtype">int</span> main() {
  <span class="comment">/* </span>
<span class="comment">   * the Pcre class throws errors via exceptions</span>
<span class="comment">   */</span>
  <span class="keywordflow">try</span> {
    cout &lt;&lt; endl &lt;&lt; <span class="stringliteral">"SEARCH() sample:"</span> &lt;&lt; endl;
    regex();

    cout &lt;&lt; endl &lt;&lt; <span class="stringliteral">"REPLACE() sample:"</span> &lt;&lt; endl;
    <a class="code" href="classPcre.html#a23">replace</a>();

    cout &lt;&lt; endl &lt;&lt; <span class="stringliteral">"Multiple REPLACE() sample:"</span> &lt;&lt; endl;
    replace_multi();

    cout &lt;&lt; endl &lt;&lt; <span class="stringliteral">"Normalizing REPLACE() sample:"</span> &lt;&lt; endl;
    normalize();

    cout &lt;&lt; endl &lt;&lt; <span class="stringliteral">"SPLIT() sample:"</span> &lt;&lt; endl;
    <a class="code" href="classPcre.html#a18">split</a>();

    cout &lt;&lt; endl &lt;&lt; <span class="stringliteral">"COPY+Operator sample:"</span> &lt;&lt; endl;
    mycopy();

    cout &lt;&lt; endl &lt;&lt; <span class="stringliteral">"Multi line search test:"</span> &lt;&lt; endl;
    multisearch();

    cout &lt;&lt; endl &lt;&lt; <span class="stringliteral">"Pcre::exception test:"</span> &lt;&lt; endl;
    ex();

    exit(0);
  }
  <span class="keywordflow">catch</span> (<a class="code" href="classPcre_1_1exception.html">Pcre::exception</a> &amp;E) {
    <span class="comment">/*</span>
<span class="comment">     * the Pcre class has thrown an exception</span>
<span class="comment">     */</span>
    cerr &lt;&lt; <span class="stringliteral">"Pcre++ error: "</span> &lt;&lt; E.what() &lt;&lt; endl;
    exit(-1);
  }
  exit(0);
}
  
</pre></div><p>
Compile your programs which use the prce++ class using the following command line: <div class="fragment"><pre>
   g++ -c yourcode.o `pcre-config --cflags` `pcre++-config --cflags`
   g++ yourcode.o `pcre-config --libs` `pcre++-config --libs` -o yourprogram
 
</pre></div><p>
If you want to learn more about regular expressions which can be used with pcre++, then please read the following documentation: <a href="perlre.html">perlre - Perl regular expressions</a><p>
The pcre library itself does also contain some usefull documentation, which maybe interesting for you: <a href="pcre.html">PCRE manual page</a> 
<p>

<p>
Definition at line <a class="el" href="pcre++_8h-source.html#l00095">95</a> of file <a class="el" href="pcre++_8h-source.html">pcre++.h</a>.<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a name="a0" doxytag="Pcre::Pcre"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> Pcre::Pcre </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Empty Constructor. Create a new empty Pcre object. This is the simplest constructor available, you might consider one of the other constructors as a better solution. You need to initialize thie Pcre object, if you use the empty constructor. You can use one of the two available operator= operators to assign it an expression or a Pcre copy.<p>
<dl compact><dt><b>Returns:</b></dt><dd>A new empty Pcre object </dd></dl>

<p>
Definition at line <a class="el" href="pcre++_8cc-source.html#l00086">86</a> of file <a class="el" href="pcre++_8cc-source.html">pcre++.cc</a>.    </td>
  </tr>
</table>
<a name="a1" doxytag="Pcre::Pcre"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> Pcre::Pcre </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const std::string &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>expression</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Constructor. Compile the given pattern. An Pcre object created this way can be used multiple times to do searches.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>expression</em>&nbsp;</td><td>a string, which must be a valid perl regular expression. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A new Pcre object, which holds te compiled pattern. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classPcre.html#a2">Pcre(const std::string&amp; expression, const std::string&amp; flags)</a> </dd></dl>

<p>
Definition at line <a class="el" href="pcre++_8cc-source.html#l00049">49</a> of file <a class="el" href="pcre++_8cc-source.html">pcre++.cc</a>.    </td>
  </tr>
</table>
<a name="a2" doxytag="Pcre::Pcre"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> Pcre::Pcre </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const std::string &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>expression</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const std::string &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>flags</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Constructor. Compile the given pattern. An Pcre object created this way can be used multiple times to do searches.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>expression</em>&nbsp;</td><td>a string, which must be a valid perl regular expression. </td></tr>
    <tr><td valign=top><em>flags</em>&nbsp;</td><td>can be one or more of the following letters:</td></tr>
  </table>
</dl>
<ul>
<li><b>i</b> Search case insensitive.</li></ul>
<p>
<ul>
<li><b>m</b> Match on multiple lines, thus ^ and $ are interpreted as the start and end of the entire string, not of a single line.</li></ul>
<p>
<ul>
<li><b>s</b> A dot in an expression matches newlines too(which is normally not the case).</li></ul>
<p>
<ul>
<li><b>x</b> Whitespace characters will be ignored (except within character classes or if escaped).</li></ul>
<p>
<ul>
<li><b>g</b> Match multiple times. This flags affects only the behavior of the <a class="el" href="classPcre.html#a23">replace(const std::string&amp; piece, const std::string&amp; with)</a> method.</li></ul>
<p>
<dl compact><dt><b>Returns:</b></dt><dd>A new Pcre object, which holds te compiled pattern. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classPcre.html#a1">Pcre(const std::string&amp; expression)</a> </dd></dl>

<p>
Definition at line <a class="el" href="pcre++_8cc-source.html#l00057">57</a> of file <a class="el" href="pcre++_8cc-source.html">pcre++.cc</a>.    </td>
  </tr>
</table>
<a name="a3" doxytag="Pcre::Pcre"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> Pcre::Pcre </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const Pcre &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>P</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Copy Constructor Creates a new Pcre object of an existing one. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>P</em>&nbsp;</td><td>an existing Pcre object. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A new Pcre object, which holds te compiled pattern. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classPcre.html#a1">Pcre(const std::string&amp; expression)</a> <p>
<a class="el" href="classPcre.html#a2">Pcre(const std::string&amp; expression, const std::string&amp; flags)</a> </dd></dl>

<p>
Definition at line <a class="el" href="pcre++_8cc-source.html#l00077">77</a> of file <a class="el" href="pcre++_8cc-source.html">pcre++.cc</a>.
<p>
References <a class="el" href="pcre++_8h-source.html#l00097">_expression</a>, <a class="el" href="pcre++_8h-source.html#l00098">_flags</a>, <a class="el" href="pcre++_8h-source.html#l00099">case_t</a>, and <a class="el" href="pcre++_8h-source.html#l00099">global_t</a>.    </td>
  </tr>
</table>
<a name="a6" doxytag="Pcre::~Pcre"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> Pcre::~Pcre </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Destructor. The desturcor will automatically invoked if the object is no more used. It frees all the memory allocated by pcre++. 
<p>
Definition at line <a class="el" href="pcre++_8cc-source.html#l00099">99</a> of file <a class="el" href="pcre++_8cc-source.html">pcre++.cc</a>.
<p>
References <a class="el" href="pcre++_8h-source.html#l00170">num_matches</a>.    </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a name="a10" doxytag="Pcre::get_match"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> string Pcre::get_match </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>pos</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get a substring at a known position. This method throws an out-of-range exception if the given position is invalid. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>pos</em>&nbsp;</td><td>the position of the substring to return. Identical to perl's $1..$n. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the substring at the given position.</dd></dl>
Example: <div class="fragment"><pre>
 
 std::string mysub = regex.get_match(1); 
 
 
</pre></div>Get the first substring that metched the expression in the "regex" object. 
<p>
Definition at line <a class="el" href="get_8cc-source.html#l00059">59</a> of file <a class="el" href="get_8cc-source.html">get.cc</a>.
<p>
References <a class="el" href="pcre++_8h-source.html#l00065">ArrayIterator</a>, and <a class="el" href="pcre++_8h-source.html#l00170">num_matches</a>.    </td>
  </tr>
</table>
<a name="a14" doxytag="Pcre::get_match_end"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int Pcre::get_match_end </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the end position of the entire match within the searched string. This method returns the character position of the last character of the entire match within the searched string. <dl compact><dt><b>Returns:</b></dt><dd>the integer character position of the last character of the entire match.</dd></dl>
Example: <div class="fragment"><pre>

 <a class="code" href="classPcre.html">Pcre</a> regex(<span class="stringliteral">"([0-9]+)\s([a-z]+)"</span>);     <span class="comment">// search for the date(makes 2 substrings</span>
 regex.<a class="code" href="classPcre.html#a7">search</a>(<span class="stringliteral">"The 11th september."</span>);  <span class="comment">// do the search on this string</span>
 <span class="keywordtype">int</span> pos = regex.<a class="code" href="classPcre.html#a12">get_match_end</a>();      <span class="comment">// returns 17, because "11th september", which is</span>
                                           <span class="comment">// the entire match, ends at the</span>
                                       <span class="comment">// 17th character inside the search string.</span>

 
</pre></div><dl compact><dt><b>See also:</b></dt><dd>int <a class="el" href="classPcre.html#a13">get_match_start()</a> <p>
int <a class="el" href="classPcre.html#a11">get_match_start(int pos)</a> <p>
int <a class="el" href="classPcre.html#a12">get_match_end(int pos)</a> </dd></dl>

<p>
Definition at line <a class="el" href="get_8cc-source.html#l00076">76</a> of file <a class="el" href="get_8cc-source.html">get.cc</a>.
<p>
Referenced by <a class="el" href="replace_8cc-source.html#l00050">replace()</a>.    </td>
  </tr>
</table>
<a name="a12" doxytag="Pcre::get_match_end"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int Pcre::get_match_end </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>pos</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the end position of a substring within the searched string. This method returns the character position of the last character of a substring withing the searched string. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>pos</em>&nbsp;</td><td>the position of the substring. Identical to perl's $1..$n. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the integer character position of the last character of a substring. Positions are starting at 0.</dd></dl>
Example: <div class="fragment"><pre>

 <a class="code" href="classPcre.html">Pcre</a> regex(<span class="stringliteral">"([0-9]+)"</span>);               <span class="comment">// search for numerical characters</span>
 regex.<a class="code" href="classPcre.html#a7">search</a>(<span class="stringliteral">"The 11th september."</span>);  <span class="comment">// do the search on this string</span>
 std::string day = regex.<a class="code" href="classPcre.html#a10">get_match</a>(1);      <span class="comment">// returns "11"</span>
 <span class="keywordtype">int</span> pos = regex.<a class="code" href="classPcre.html#a12">get_match_end</a>(1);     <span class="comment">// returns 5, because "11" ends at the</span>
                                       <span class="comment">// 5th character inside the search string.</span>

 
</pre></div><dl compact><dt><b>See also:</b></dt><dd>int <a class="el" href="classPcre.html#a11">get_match_start(int pos)</a> <p>
int <a class="el" href="classPcre.html#a13">get_match_start()</a> <p>
int <a class="el" href="classPcre.html#a14">get_match_end()</a> </dd></dl>

<p>
Definition at line <a class="el" href="get_8cc-source.html#l00095">95</a> of file <a class="el" href="get_8cc-source.html">get.cc</a>.
<p>
References <a class="el" href="pcre++_8h-source.html#l00170">num_matches</a>.    </td>
  </tr>
</table>
<a name="a15" doxytag="Pcre::get_match_length"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> size_t Pcre::get_match_length </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>pos</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the length of a substring at a known position. This method throws an out-of-range exception if the given position is invalid. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>pos</em>&nbsp;</td><td>the position of the substring-length to return. Identical to perl's $1..$n. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the length substring at the given position. </dd></dl>

<p>
Definition at line <a class="el" href="get_8cc-source.html#l00109">109</a> of file <a class="el" href="get_8cc-source.html">get.cc</a>.
<p>
References <a class="el" href="pcre++_8h-source.html#l00065">ArrayIterator</a>, and <a class="el" href="pcre++_8h-source.html#l00170">num_matches</a>.    </td>
  </tr>
</table>
<a name="a13" doxytag="Pcre::get_match_start"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int Pcre::get_match_start </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the start position of the entire match within the searched string. This method returns the character position of the first character of the entire match within the searched string. <dl compact><dt><b>Returns:</b></dt><dd>the integer character position of the first character of the entire match.</dd></dl>
Example: <div class="fragment"><pre>

 <a class="code" href="classPcre.html">Pcre</a> regex(<span class="stringliteral">"([0-9]+)\s([a-z]+)"</span>);     <span class="comment">// search for the date(makes 2 substrings</span>
 regex.<a class="code" href="classPcre.html#a7">search</a>(<span class="stringliteral">"The 11th september."</span>);  <span class="comment">// do the search on this string</span>
 <span class="keywordtype">int</span> pos = regex.<a class="code" href="classPcre.html#a11">get_match_start</a>();    <span class="comment">// returns 4, because "11th september" begins at the</span>
                                       <span class="comment">// 4th character inside the search string.</span>

 
</pre></div><dl compact><dt><b>See also:</b></dt><dd>int <a class="el" href="classPcre.html#a11">get_match_start(int pos)</a> <p>
int <a class="el" href="classPcre.html#a12">get_match_end(int pos)</a> <p>
int <a class="el" href="classPcre.html#a14">get_match_end()</a> </dd></dl>

<p>
Definition at line <a class="el" href="get_8cc-source.html#l00069">69</a> of file <a class="el" href="get_8cc-source.html">get.cc</a>.
<p>
Referenced by <a class="el" href="replace_8cc-source.html#l00050">replace()</a>.    </td>
  </tr>
</table>
<a name="a11" doxytag="Pcre::get_match_start"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int Pcre::get_match_start </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>pos</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the start position of a substring within the searched string. This method returns the character position of the first character of a substring withing the searched string. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>pos</em>&nbsp;</td><td>the position of the substring. Identical to perl's $1..$n. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the integer character position of the first character of a substring. Positions are starting at 0.</dd></dl>
Example: <div class="fragment"><pre>
 
 <a class="code" href="classPcre.html">Pcre</a> regex(<span class="stringliteral">"([0-9]+)"</span>);               <span class="comment">// search for numerical characters</span>
 regex.<a class="code" href="classPcre.html#a7">search</a>(<span class="stringliteral">"The 11th september."</span>);  <span class="comment">// do the search on this string</span>
 std::string day = regex.<a class="code" href="classPcre.html#a10">get_match</a>(1);      <span class="comment">// returns "11"</span>
 <span class="keywordtype">int</span> pos = regex.<a class="code" href="classPcre.html#a11">get_match_start</a>(1);   <span class="comment">// returns 4, because "11" begins at the</span>
                                       <span class="comment">// 4th character inside the search string.</span>

 
</pre></div><dl compact><dt><b>See also:</b></dt><dd>int <a class="el" href="classPcre.html#a12">get_match_end(int pos)</a> <p>
int <a class="el" href="classPcre.html#a14">get_match_end()</a> <p>
int <a class="el" href="classPcre.html#a13">get_match_start()</a> </dd></dl>

<p>
Definition at line <a class="el" href="get_8cc-source.html#l00083">83</a> of file <a class="el" href="get_8cc-source.html">get.cc</a>.
<p>
References <a class="el" href="pcre++_8h-source.html#l00170">num_matches</a>.    </td>
  </tr>
</table>
<a name="a9" doxytag="Pcre::get_sub_strings"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="pcre++_8h.html#a1">Array</a> * Pcre::get_sub_strings </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return a vector of substrings, if any. <dl compact><dt><b>Returns:</b></dt><dd>a pointer to an Array, which may be NULL, if no substrings has been found. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="pcre++_8h.html#a1">Array</a> </dd></dl>

<p>
Definition at line <a class="el" href="get_8cc-source.html#l00052">52</a> of file <a class="el" href="get_8cc-source.html">get.cc</a>.
<p>
References <a class="el" href="pcre++_8h-source.html#l00062">Array</a>.    </td>
  </tr>
</table>
<a name="a16" doxytag="Pcre::matched"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> bool Pcre::matched </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Test if a search was successfull. This method must be invoked <b>after</b> calling <a class="el" href="classPcre.html#a7">search()</a>. <dl compact><dt><b>Returns:</b></dt><dd>boolean <b>true</b> if the search was successfull at all, or <b>false</b> if not. </dd></dl>

<p>
Definition at line <a class="el" href="pcre++_8h-source.html#l00409">409</a> of file <a class="el" href="pcre++_8h-source.html">pcre++.h</a>.
<p>
Referenced by <a class="el" href="replace_8cc-source.html#l00050">replace()</a>.    </td>
  </tr>
</table>
<a name="a17" doxytag="Pcre::matches"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int Pcre::matches </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the number of substrings generated by pcre++. <dl compact><dt><b>Returns:</b></dt><dd>the number of substrings generated by pcre++. </dd></dl>

<p>
Definition at line <a class="el" href="pcre++_8h-source.html#l00414">414</a> of file <a class="el" href="pcre++_8h-source.html">pcre++.h</a>.
<p>
Referenced by <a class="el" href="replace_8cc-source.html#l00050">replace()</a>.    </td>
  </tr>
</table>
<a name="a5" doxytag="Pcre::operator="></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> const Pcre &amp; Pcre::operator= </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const Pcre &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>P</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Operator =. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>&amp;P</em>&nbsp;</td><td>an Pcre object </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>a new Pcre object</dd></dl>
Example:<p>
<div class="fragment"><pre>
 <a class="code" href="classPcre.html">Pcre</a> reg1(<span class="stringliteral">"^[a-z]+?"</span>);
 <a class="code" href="classPcre.html">Pcre</a> reg2;
 reg2 = reg1;
 
</pre></div>
<p>
Definition at line <a class="el" href="pcre++_8cc-source.html#l00132">132</a> of file <a class="el" href="pcre++_8cc-source.html">pcre++.cc</a>.
<p>
References <a class="el" href="pcre++_8h-source.html#l00097">_expression</a>, <a class="el" href="pcre++_8h-source.html#l00098">_flags</a>, <a class="el" href="pcre++_8h-source.html#l00099">case_t</a>, and <a class="el" href="pcre++_8h-source.html#l00099">global_t</a>.    </td>
  </tr>
</table>
<a name="a4" doxytag="Pcre::operator="></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> const Pcre &amp; Pcre::operator= </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const std::string &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>expression</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Operator =. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>expression</em>&nbsp;</td><td>a valid regular expression. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>a new Pcre object.</dd></dl>
Example:<p>
<div class="fragment"><pre>
 <a class="code" href="classPcre.html">Pcre</a> regex = <span class="stringliteral">"(A+?)"</span>;
 
</pre></div>
<p>
Definition at line <a class="el" href="pcre++_8cc-source.html#l00121">121</a> of file <a class="el" href="pcre++_8cc-source.html">pcre++.cc</a>.    </td>
  </tr>
</table>
<a name="a23" doxytag="Pcre::replace"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> string Pcre::replace </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const std::string &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>piece</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const std::string &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>with</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Replace parts of a string using regular expressions. This method is the counterpart of the perl s/// operator. It replaces the substrings which matched the given regular expression (given to the constructor) with the supplied string.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>piece</em>&nbsp;</td><td>the string in which you want to search and replace. </td></tr>
    <tr><td valign=top><em>with</em>&nbsp;</td><td>the string which you want to place on the positions which match the expression (given to the constructor). </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="replace_8cc-source.html#l00050">50</a> of file <a class="el" href="replace_8cc-source.html">replace.cc</a>.
<p>
References <a class="el" href="pcre++_8h-source.html#l00057">__pcredebug</a>, <a class="el" href="pcre++_8h-source.html#l00169">did_match</a>, <a class="el" href="get_8cc-source.html#l00076">get_match_end()</a>, <a class="el" href="get_8cc-source.html#l00069">get_match_start()</a>, <a class="el" href="pcre++_8h-source.html#l00409">matched()</a>, <a class="el" href="pcre++_8h-source.html#l00414">matches()</a>, <a class="el" href="pcre++_8h-source.html#l00170">num_matches</a>, and <a class="el" href="search_8cc-source.html#l00087">search()</a>.    </td>
  </tr>
</table>
<a name="a8" doxytag="Pcre::search"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> bool Pcre::search </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const std::string &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>stuff</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>OffSet</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Do a search on the given string beginning at the given offset. This method does the actual search on the given string. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>stuff</em>&nbsp;</td><td>the string in which you want to search for something. </td></tr>
    <tr><td valign=top><em>OffSet</em>&nbsp;</td><td>the offset where to start the search. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>boolean <b>true</b> if the regular expression matched. <b>false</b> if not. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd>bool <a class="el" href="classPcre.html#a7">search(const std::string&amp; stuff)</a> </dd></dl>

<p>
Definition at line <a class="el" href="search_8cc-source.html#l00083">83</a> of file <a class="el" href="search_8cc-source.html">search.cc</a>.    </td>
  </tr>
</table>
<a name="a7" doxytag="Pcre::search"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> bool Pcre::search </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const std::string &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>stuff</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Do a search on the given string. This method does the actual search on the given string. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>stuff</em>&nbsp;</td><td>the string in which you want to search for something. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>boolean <b>true</b> if the regular expression matched. <b>false</b> if not. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd>bool <a class="el" href="classPcre.html#a8">search(const std::string&amp; stuff, int OffSet)</a> </dd></dl>

<p>
Definition at line <a class="el" href="search_8cc-source.html#l00087">87</a> of file <a class="el" href="search_8cc-source.html">search.cc</a>.
<p>
Referenced by <a class="el" href="replace_8cc-source.html#l00050">replace()</a>.    </td>
  </tr>
</table>
<a name="a22" doxytag="Pcre::split"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="pcre++_8h.html#a1">Array</a> Pcre::split </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const std::string &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>piece</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>std::vector&lt; int &gt;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>positions</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
split a string into pieces This method will split the given string into a vector of strings using the compiled expression (given to the constructor).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>piece</em>&nbsp;</td><td>The string you want to split into it's parts. </td></tr>
    <tr><td valign=top><em>positions</em>&nbsp;</td><td>a std::vector&lt;int&gt; of positions, which the returned Array should contain. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>an Array of strings </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="pcre++_8h.html#a1">Array</a> <a class="el" href="classPcre.html#a18">split(const std::string&amp; piece)</a> <p>
<a class="el" href="pcre++_8h.html#a1">Array</a> <a class="el" href="classPcre.html#a19">split(const std::string&amp; piece, int limit)</a> <p>
<a class="el" href="pcre++_8h.html#a1">Array</a> <a class="el" href="classPcre.html#a20">split(const std::string&amp; piece, int limit, int start_offset)</a> <p>
<a class="el" href="pcre++_8h.html#a1">Array</a> <a class="el" href="classPcre.html#a20">split(const std::string&amp; piece, int limit, int start_offset)</a> <p>
<a class="el" href="pcre++_8h.html#a1">Array</a> </dd></dl>

<p>
Definition at line <a class="el" href="split_8cc-source.html#l00150">150</a> of file <a class="el" href="split_8cc-source.html">split.cc</a>.
<p>
References <a class="el" href="pcre++_8h-source.html#l00062">Array</a>.    </td>
  </tr>
</table>
<a name="a21" doxytag="Pcre::split"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="pcre++_8h.html#a1">Array</a> Pcre::split </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const std::string &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>piece</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>limit</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>start_offset</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>end_offset</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
split a string into pieces This method will split the given string into a vector of strings using the compiled expression (given to the constructor).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>piece</em>&nbsp;</td><td>The string you want to split into it's parts. </td></tr>
    <tr><td valign=top><em>limit</em>&nbsp;</td><td>the maximum number of elements you want to get back from <a class="el" href="classPcre.html#a18">split()</a>. </td></tr>
    <tr><td valign=top><em>start_offset</em>&nbsp;</td><td>at which substring the returned Array should start. </td></tr>
    <tr><td valign=top><em>end_offset</em>&nbsp;</td><td>at which substring the returned Array should end. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>an Array of strings </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="pcre++_8h.html#a1">Array</a> <a class="el" href="classPcre.html#a18">split(const std::string&amp; piece)</a> <p>
<a class="el" href="pcre++_8h.html#a1">Array</a> <a class="el" href="classPcre.html#a19">split(const std::string&amp; piece, int limit)</a> <p>
<a class="el" href="pcre++_8h.html#a1">Array</a> <a class="el" href="classPcre.html#a20">split(const std::string&amp; piece, int limit, int start_offset)</a> <p>
<a class="el" href="pcre++_8h.html#a1">Array</a> <a class="el" href="classPcre.html#a22">split(const std::string&amp; piece, std::vector&lt;int&gt; positions)</a> <p>
<a class="el" href="pcre++_8h.html#a1">Array</a> </dd></dl>

<p>
Definition at line <a class="el" href="split_8cc-source.html#l00146">146</a> of file <a class="el" href="split_8cc-source.html">split.cc</a>.
<p>
References <a class="el" href="pcre++_8h-source.html#l00062">Array</a>.    </td>
  </tr>
</table>
<a name="a20" doxytag="Pcre::split"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="pcre++_8h.html#a1">Array</a> Pcre::split </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const std::string &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>piece</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>limit</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>start_offset</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
split a string into pieces This method will split the given string into a vector of strings using the compiled expression (given to the constructor).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>piece</em>&nbsp;</td><td>The string you want to split into it's parts. </td></tr>
    <tr><td valign=top><em>limit</em>&nbsp;</td><td>the maximum number of elements you want to get back from <a class="el" href="classPcre.html#a18">split()</a>. </td></tr>
    <tr><td valign=top><em>start_offset</em>&nbsp;</td><td>at which substring the returned Array should start. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>an Array of strings </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="pcre++_8h.html#a1">Array</a> <p>
<a class="el" href="pcre++_8h.html#a1">Array</a> <a class="el" href="classPcre.html#a18">split(const std::string&amp; piece)</a> <p>
<a class="el" href="pcre++_8h.html#a1">Array</a> <a class="el" href="classPcre.html#a19">split(const std::string&amp; piece, int limit)</a> <p>
<a class="el" href="pcre++_8h.html#a1">Array</a> <a class="el" href="classPcre.html#a21">split(const std::string&amp; piece, int limit, int start_offset, int end_offset)</a> <p>
<a class="el" href="pcre++_8h.html#a1">Array</a> <a class="el" href="classPcre.html#a22">split(const std::string&amp; piece, std::vector&lt;int&gt; positions)</a> </dd></dl>

<p>
Definition at line <a class="el" href="split_8cc-source.html#l00142">142</a> of file <a class="el" href="split_8cc-source.html">split.cc</a>.
<p>
References <a class="el" href="pcre++_8h-source.html#l00062">Array</a>.    </td>
  </tr>
</table>
<a name="a19" doxytag="Pcre::split"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="pcre++_8h.html#a1">Array</a> Pcre::split </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const std::string &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>piece</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>limit</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
split a string into pieces This method will split the given string into a vector of strings using the compiled expression (given to the constructor).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>piece</em>&nbsp;</td><td>The string you want to split into it's parts. </td></tr>
    <tr><td valign=top><em>limit</em>&nbsp;</td><td>the maximum number of elements you want to get back from <a class="el" href="classPcre.html#a18">split()</a>. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>an Array of strings </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="pcre++_8h.html#a1">Array</a> <p>
<a class="el" href="pcre++_8h.html#a1">Array</a> <a class="el" href="classPcre.html#a18">split(const std::string&amp; piece)</a> <p>
<a class="el" href="pcre++_8h.html#a1">Array</a> <a class="el" href="classPcre.html#a20">split(const std::string&amp; piece, int limit, int start_offset)</a> <p>
<a class="el" href="pcre++_8h.html#a1">Array</a> <a class="el" href="classPcre.html#a21">split(const std::string&amp; piece, int limit, int start_offset, int end_offset)</a> <p>
<a class="el" href="pcre++_8h.html#a1">Array</a> <a class="el" href="classPcre.html#a22">split(const std::string&amp; piece, std::vector&lt;int&gt; positions)</a> </dd></dl>

<p>
Definition at line <a class="el" href="split_8cc-source.html#l00138">138</a> of file <a class="el" href="split_8cc-source.html">split.cc</a>.
<p>
References <a class="el" href="pcre++_8h-source.html#l00062">Array</a>.    </td>
  </tr>
</table>
<a name="a18" doxytag="Pcre::split"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="pcre++_8h.html#a1">Array</a> Pcre::split </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const std::string &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>piece</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
split a string into pieces This method will split the given string into a vector of strings using the compiled expression (given to the constructor).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>piece</em>&nbsp;</td><td>The string you want to split into it's parts. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>an Array of strings </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="pcre++_8h.html#a1">Array</a> <p>
<a class="el" href="pcre++_8h.html#a1">Array</a> <a class="el" href="classPcre.html#a19">split(const std::string&amp; piece, int limit)</a> <p>
<a class="el" href="pcre++_8h.html#a1">Array</a> <a class="el" href="classPcre.html#a20">split(const std::string&amp; piece, int limit, int start_offset)</a> <p>
<a class="el" href="pcre++_8h.html#a1">Array</a> <a class="el" href="classPcre.html#a21">split(const std::string&amp; piece, int limit, int start_offset, int end_offset)</a> <p>
<a class="el" href="pcre++_8h.html#a1">Array</a> <a class="el" href="classPcre.html#a22">split(const std::string&amp; piece, std::vector&lt;int&gt; positions)</a> </dd></dl>

<p>
Definition at line <a class="el" href="split_8cc-source.html#l00134">134</a> of file <a class="el" href="split_8cc-source.html">split.cc</a>.
<p>
References <a class="el" href="pcre++_8h-source.html#l00062">Array</a>.    </td>
  </tr>
</table>
<hr><h2>Member Data Documentation</h2>
<a name="m0" doxytag="Pcre::did_match"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> bool Pcre::did_match
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="pcre++_8h-source.html#l00169">169</a> of file <a class="el" href="pcre++_8h-source.html">pcre++.h</a>.
<p>
Referenced by <a class="el" href="replace_8cc-source.html#l00050">replace()</a>.    </td>
  </tr>
</table>
<a name="m1" doxytag="Pcre::num_matches"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int Pcre::num_matches
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
true if the expression produced a match 
<p>
Definition at line <a class="el" href="pcre++_8h-source.html#l00170">170</a> of file <a class="el" href="pcre++_8h-source.html">pcre++.h</a>.
<p>
Referenced by <a class="el" href="get_8cc-source.html#l00059">get_match()</a>, <a class="el" href="get_8cc-source.html#l00095">get_match_end()</a>, <a class="el" href="get_8cc-source.html#l00109">get_match_length()</a>, <a class="el" href="get_8cc-source.html#l00083">get_match_start()</a>, <a class="el" href="replace_8cc-source.html#l00050">replace()</a>, and <a class="el" href="pcre++_8cc-source.html#l00099">~Pcre()</a>.    </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="pcre++_8h-source.html">pcre++.h</a><li><a class="el" href="pcre++_8cc-source.html">pcre++.cc</a><li><a class="el" href="replace_8cc-source.html">replace.cc</a><li><a class="el" href="search_8cc-source.html">search.cc</a><li><a class="el" href="split_8cc-source.html">split.cc</a><li><a class="el" href="get_8cc-source.html">get.cc</a></ul>
<hr><address style="align: right;"><small>Generated on Thu Jun 26 23:05:31 2003 for PCRE++ by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.3-rc3 </small></address>
</body>
</html>
