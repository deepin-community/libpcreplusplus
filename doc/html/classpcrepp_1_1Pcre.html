<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>pcrepp::Pcre class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3-rc3 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>pcrepp::Pcre Class Reference</h1><code>#include &lt;<a class="el" href="pcre++_8h-source.html">pcre++.h</a>&gt;</code>
<p>
<a href="classpcrepp_1_1Pcre-members.html">List of all members.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Public Member Functions</h2></td></tr>
<tr><td nowrap align=right valign=top>&nbsp;</td><td valign=bottom><a class="el" href="classpcrepp_1_1Pcre.html#a0">Pcre</a> ()</td></tr>
<tr><td nowrap align=right valign=top>&nbsp;</td><td valign=bottom><a class="el" href="classpcrepp_1_1Pcre.html#a1">Pcre</a> (const std::string &amp;expression)</td></tr>
<tr><td nowrap align=right valign=top>&nbsp;</td><td valign=bottom><a class="el" href="classpcrepp_1_1Pcre.html#a2">Pcre</a> (const std::string &amp;expression, const std::string &amp;flags)</td></tr>
<tr><td nowrap align=right valign=top>&nbsp;</td><td valign=bottom><a class="el" href="classpcrepp_1_1Pcre.html#a3">Pcre</a> (const std::string &amp;expression, unsigned int flags)</td></tr>
<tr><td nowrap align=right valign=top>&nbsp;</td><td valign=bottom><a class="el" href="classpcrepp_1_1Pcre.html#a4">Pcre</a> (const Pcre &amp;P)</td></tr>
<tr><td nowrap align=right valign=top>const Pcre &amp;&nbsp;</td><td valign=bottom><a class="el" href="classpcrepp_1_1Pcre.html#a5">operator=</a> (const std::string &amp;expression)</td></tr>
<tr><td nowrap align=right valign=top>const Pcre &amp;&nbsp;</td><td valign=bottom><a class="el" href="classpcrepp_1_1Pcre.html#a6">operator=</a> (const Pcre &amp;P)</td></tr>
<tr><td nowrap align=right valign=top>&nbsp;</td><td valign=bottom><a class="el" href="classpcrepp_1_1Pcre.html#a7">~Pcre</a> ()</td></tr>
<tr><td nowrap align=right valign=top>bool&nbsp;</td><td valign=bottom><a class="el" href="classpcrepp_1_1Pcre.html#a8">search</a> (const std::string &amp;stuff)</td></tr>
<tr><td nowrap align=right valign=top>bool&nbsp;</td><td valign=bottom><a class="el" href="classpcrepp_1_1Pcre.html#a9">search</a> (const std::string &amp;stuff, int OffSet)</td></tr>
<tr><td nowrap align=right valign=top>std::vector&lt; std::string &gt; *&nbsp;</td><td valign=bottom><a class="el" href="classpcrepp_1_1Pcre.html#a10">get_sub_strings</a> () const</td></tr>
<tr><td nowrap align=right valign=top>std::string&nbsp;</td><td valign=bottom><a class="el" href="classpcrepp_1_1Pcre.html#a11">get_match</a> (int pos) const</td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classpcrepp_1_1Pcre.html#a12">get_match_start</a> (int pos) const</td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classpcrepp_1_1Pcre.html#a13">get_match_end</a> (int pos) const</td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classpcrepp_1_1Pcre.html#a14">get_match_start</a> () const</td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classpcrepp_1_1Pcre.html#a15">get_match_end</a> () const</td></tr>
<tr><td nowrap align=right valign=top>size_t&nbsp;</td><td valign=bottom><a class="el" href="classpcrepp_1_1Pcre.html#a16">get_match_length</a> (int pos) const</td></tr>
<tr><td nowrap align=right valign=top>bool&nbsp;</td><td valign=bottom><a class="el" href="classpcrepp_1_1Pcre.html#a17">matched</a> () const</td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classpcrepp_1_1Pcre.html#a18">matches</a> () const</td></tr>
<tr><td nowrap align=right valign=top>std::vector&lt; std::string &gt;&nbsp;</td><td valign=bottom><a class="el" href="classpcrepp_1_1Pcre.html#a19">split</a> (const std::string &amp;piece)</td></tr>
<tr><td nowrap align=right valign=top>std::vector&lt; std::string &gt;&nbsp;</td><td valign=bottom><a class="el" href="classpcrepp_1_1Pcre.html#a20">split</a> (const std::string &amp;piece, int limit)</td></tr>
<tr><td nowrap align=right valign=top>std::vector&lt; std::string &gt;&nbsp;</td><td valign=bottom><a class="el" href="classpcrepp_1_1Pcre.html#a21">split</a> (const std::string &amp;piece, int limit, int start_offset)</td></tr>
<tr><td nowrap align=right valign=top>std::vector&lt; std::string &gt;&nbsp;</td><td valign=bottom><a class="el" href="classpcrepp_1_1Pcre.html#a22">split</a> (const std::string &amp;piece, int limit, int start_offset, int end_offset)</td></tr>
<tr><td nowrap align=right valign=top>std::vector&lt; std::string &gt;&nbsp;</td><td valign=bottom><a class="el" href="classpcrepp_1_1Pcre.html#a23">split</a> (const std::string &amp;piece, std::vector&lt; int &gt; positions)</td></tr>
<tr><td nowrap align=right valign=top>std::string&nbsp;</td><td valign=bottom><a class="el" href="classpcrepp_1_1Pcre.html#a24">replace</a> (const std::string &amp;piece, const std::string &amp;with)</td></tr>
<tr><td nowrap align=right valign=top>pcre *&nbsp;</td><td valign=bottom><a class="el" href="classpcrepp_1_1Pcre.html#a25">get_pcre</a> ()</td></tr>
<tr><td nowrap align=right valign=top>pcre_extra *&nbsp;</td><td valign=bottom><a class="el" href="classpcrepp_1_1Pcre.html#a26">get_pcre_extra</a> ()</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classpcrepp_1_1Pcre.html#a27">study</a> ()</td></tr>
<tr><td nowrap align=right valign=top>bool&nbsp;</td><td valign=bottom><a class="el" href="classpcrepp_1_1Pcre.html#a28">setlocale</a> (const char *locale)</td></tr>
<tr><td nowrap align=right valign=top>std::string&nbsp;</td><td valign=bottom><a class="el" href="classpcrepp_1_1Pcre.html#a29">operator[]</a> (int index)</td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
The <a class="el" href="classpcrepp_1_1Pcre.html">Pcre</a> class is a wrapper around the PCRE library.<p>
The library "pcre++" defines a class named "Pcre" which you can use to search in strings using reular expressions as well as getting matched sub strings. It does currently not support all features, which the underlying PCRE library provides, but the most important stuff is implemented.<p>
Please study this example code to learn how to use this class: <div class="fragment"><pre><span class="comment">/*</span>
<span class="comment"> *</span>
<span class="comment"> *  This file  is part of the PCRE++ Class Library.</span>
<span class="comment"> *</span>
<span class="comment"> *  By  accessing  this software,  PCRE++, you  are  duly informed</span>
<span class="comment"> *  of and agree to be  bound  by the  conditions  described below</span>
<span class="comment"> *  in this notice:</span>
<span class="comment"> *</span>
<span class="comment"> *  This software product,  PCRE++,  is developed by Thomas Linden</span>
<span class="comment"> *  and  copyrighted (C) 2002  by  Thomas Linden,  with all rights </span>
<span class="comment"> *  reserved.</span>
<span class="comment"> *</span>
<span class="comment"> *  There  is no charge for PCRE++ software.  You can redistribute</span>
<span class="comment"> *  it and/or modify it under the terms of the GNU  Lesser General</span>
<span class="comment"> *  Public License, which is incorporated by reference herein.</span>
<span class="comment"> *</span>
<span class="comment"> *  PCRE++ is distributed WITHOUT ANY WARRANTY, IMPLIED OR EXPRESS,</span>
<span class="comment"> *  OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE or that</span>
<span class="comment"> *  the use of it will not infringe on any third party's intellec-</span>
<span class="comment"> *  tual property rights.</span>
<span class="comment"> *</span>
<span class="comment"> *  You should have received a copy of the GNU Lesser General Public</span>
<span class="comment"> *  License along with PCRE++.  Copies can also be obtained from:</span>
<span class="comment"> *</span>
<span class="comment"> *    http://www.gnu.org/licenses/lgpl.txt</span>
<span class="comment"> *</span>
<span class="comment"> *  or by writing to:</span>
<span class="comment"> *</span>
<span class="comment"> *  Free Software Foundation, Inc.</span>
<span class="comment"> *  59 Temple Place, Suite 330</span>
<span class="comment"> *  Boston, MA 02111-1307</span>
<span class="comment"> *  USA</span>
<span class="comment"> *</span>
<span class="comment"> *  Or contact:</span>
<span class="comment"> *</span>
<span class="comment"> *   "Thomas Linden" &lt;tom@daemon.de&gt;</span>
<span class="comment"> *</span>
<span class="comment"> *</span>
<span class="comment"> */</span>


<span class="comment">/* you need to include the pcre++ header file */</span>
<span class="preprocessor">#include "../libpcre++/pcre++.h"</span>
<span class="preprocessor">#include &lt;iostream&gt;</span>

<span class="keyword">using</span> <span class="keyword">namespace </span>std;
<span class="keyword">using</span> <span class="keyword">namespace </span>pcrepp;

<span class="comment">/* A typedef for a vector of strings (as returned by split() )*/</span>
<span class="keyword">typedef</span> std::vector&lt;std::string&gt; Array;

<span class="comment">/* A typedef for a vector iterator */</span>
<span class="keyword">typedef</span> std::vector&lt;std::string&gt;::iterator ArrayIterator;

<span class="keywordtype">void</span> regex() {
    <span class="comment">/*</span>
<span class="comment">     * define a string with a regular expression</span>
<span class="comment">     */</span>
    string expression = <span class="stringliteral">"([a-z]*) ([0-9]+)"</span>;

    <span class="comment">/*</span>
<span class="comment">     * this is the string in which we want to search</span>
<span class="comment">     */</span>
    string stuff = <span class="stringliteral">"hallo 11 robert"</span>;

    cout &lt;&lt; <span class="stringliteral">"  searching in \""</span> &lt;&lt; stuff &lt;&lt; <span class="stringliteral">"\" for regex \""</span>
         &lt;&lt; expression &lt;&lt; <span class="stringliteral">"\":"</span> &lt;&lt; endl;

    <span class="comment">/*</span>
<span class="comment">     * Create a new Pcre object, search case-insensitive ("i")</span>
<span class="comment">     */</span>
    <a class="code" href="classpcrepp_1_1Pcre.html#a0">Pcre</a> reg(expression, <span class="stringliteral">"i"</span>);
    
    <span class="comment">/*</span>
<span class="comment">     * see if the expression matched</span>
<span class="comment">     */</span>
    <span class="keywordflow">if</span>(reg.search(stuff) == <span class="keyword">true</span>) {

      <span class="comment">/*</span>
<span class="comment">       * see if the expression generated any substrings</span>
<span class="comment">       */</span>
      <span class="keywordflow">if</span>(reg.matches() &gt;= 1) {

        <span class="comment">/*</span>
<span class="comment">         * print out the number of substrings</span>
<span class="comment">         */</span>
        cout &lt;&lt; <span class="stringliteral">"  generated "</span> &lt;&lt; reg.matches() &lt;&lt; <span class="stringliteral">" substrings:"</span> &lt;&lt; endl;
          
        <span class="comment">/*</span>
<span class="comment">         * iterate over the matched sub strings</span>
<span class="comment">         */</span>
        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> pos=0; pos &lt; reg.matches(); pos++) {
          <span class="comment">/* print out each substring */</span>
          cout &lt;&lt; <span class="stringliteral">"  substring "</span> &lt;&lt; pos &lt;&lt; <span class="stringliteral">": "</span> &lt;&lt; reg[pos];   <span class="comment">// also possible: reg.get_match(pos);</span>
          <span class="comment">/* print out the start/end offset of the current substring</span>
<span class="comment">           * within the searched string(stuff)</span>
<span class="comment">           */</span>
          cout &lt;&lt; <span class="stringliteral">" (start: "</span> &lt;&lt; reg.get_match_start(pos) &lt;&lt; <span class="stringliteral">", end: "</span>
               &lt;&lt; reg.get_match_end(pos) &lt;&lt; <span class="stringliteral">")"</span> &lt;&lt; endl;
        }
      }
      <span class="keywordflow">else</span> {
        <span class="comment">/*</span>
<span class="comment">         * we had a match, but it generated no substrings, for whatever reason</span>
<span class="comment">         */</span>
        cout &lt;&lt; <span class="stringliteral">"   it matched, but there where no substrings."</span> &lt;&lt; endl;
      }
    }
    <span class="keywordflow">else</span> {
      <span class="comment">/*</span>
<span class="comment">       * no match at all</span>
<span class="comment">       */</span>
      cout &lt;&lt; <span class="stringliteral">"   didn't match."</span> &lt;&lt; endl;
    }
}



<span class="keywordtype">void</span> <a class="code" href="classpcrepp_1_1Pcre.html#a24">replace</a>() {
    <span class="comment">/*</span>
<span class="comment">     * Sample of replace() usage</span>
<span class="comment">     */</span>
    string orig = <span class="stringliteral">"Hans ist 22 Jahre alt. Er ist 8 Jahre älter als Fred."</span>;
    cout &lt;&lt; <span class="stringliteral">"   orig: "</span> &lt;&lt; orig &lt;&lt; endl;

    <span class="comment">/*</span>
<span class="comment">     * define a regex for digits (character class)</span>
<span class="comment">     */</span>
    <a class="code" href="classpcrepp_1_1Pcre.html#a0">Pcre</a> p(<span class="stringliteral">" ([0-9]+) "</span>);

    <span class="comment">/*</span>
<span class="comment">     * replace the 1st occurence of [0-9]+ with "zweiundzwanzig"</span>
<span class="comment">     */</span>
    string n = p.replace(orig, <span class="stringliteral">" zweiundzwanzig($1) "</span>);

    <span class="comment">/*</span>
<span class="comment">     * prints out: "Hans ist zweiundzwanzig Jahre alt. Er ist 8 Jahre älter</span>
<span class="comment">     * als Fred."</span>
<span class="comment">     */</span>
    cout &lt;&lt; <span class="stringliteral">"   new: "</span> &lt;&lt; n &lt;&lt; endl; 
}


<span class="keywordtype">void</span> replace_multi() {
  <span class="comment">/*</span>
<span class="comment">   * Sample of replace() usage with multiple substrings</span>
<span class="comment">   */</span>
  string orig = <span class="stringliteral">" 08:23 "</span>;
  cout &lt;&lt; <span class="stringliteral">"   orig: "</span> &lt;&lt; orig &lt;&lt; endl;
  
  <span class="comment">/*</span>
<span class="comment">   * create regex which, if it matches, creates 3 substrings</span>
<span class="comment">   */</span>
  <a class="code" href="classpcrepp_1_1Pcre.html#a0">Pcre</a> reg(<span class="stringliteral">" ([0-9]+)(:)([0-9]+) "</span>, <span class="stringliteral">"sig"</span>);

  <span class="comment">/*</span>
<span class="comment">   * remove $2 (":")</span>
<span class="comment">   * re-use $1 ("08") and $3 ("23") in the replace string</span>
<span class="comment">   */</span>
  string n  = reg.replace(orig, <span class="stringliteral">"$1 Stunden und $3 Minuten"</span>);

  <span class="comment">/*</span>
<span class="comment">   * prints the result: "08 Stunden und 23 Minuten"</span>
<span class="comment">   */</span>
  cout &lt;&lt; <span class="stringliteral">"   new:  "</span> &lt;&lt; n  &lt;&lt; endl;
}


<span class="keywordtype">void</span> normalize() {
  <span class="comment">/*</span>
<span class="comment">   * another sample to check if normalizing using replace() works</span>
<span class="comment">   */</span>
  string orig = <span class="stringliteral">"Heute   ist ein  schoener  Tag        gell?"</span>;
  cout &lt;&lt; <span class="stringliteral">"   orig: "</span> &lt;&lt; orig &lt;&lt; endl;

  <span class="comment">/*</span>
<span class="comment">   * create regex for normalizing whitespace</span>
<span class="comment">   */</span>
  <a class="code" href="classpcrepp_1_1Pcre.html#a0">Pcre</a> reg(<span class="stringliteral">"[\\s]+"</span>, <span class="stringliteral">"gs"</span>);

  <span class="comment">/*</span>
<span class="comment">   * do the normalizing process</span>
<span class="comment">   */</span>
  string n = reg.replace(orig, <span class="stringliteral">" "</span>);

  <span class="comment">/*</span>
<span class="comment">   * prints the result, should be: "Heute ist ein schoener Tag , gell?"</span>
<span class="comment">   */</span>
  cout &lt;&lt; <span class="stringliteral">"   new:  "</span> &lt;&lt; n  &lt;&lt; endl;
}


<span class="keywordtype">void</span> <a class="code" href="classpcrepp_1_1Pcre.html#a19">split</a>() {
  <span class="comment">/*</span>
<span class="comment">   * Sample of split() usage</span>
<span class="comment">   */</span>
      string sp_orig = <span class="stringliteral">"was21willst2387461du3alter!"</span>;
      cout &lt;&lt; <span class="stringliteral">"   orig: "</span> &lt;&lt; sp_orig &lt;&lt; endl;

      <span class="comment">/*</span>
<span class="comment">       * define a regex for digits (character class)</span>
<span class="comment">       */</span>
      string delimiter = <span class="stringliteral">"[0-9]+"</span>;

      <span class="comment">/*</span>
<span class="comment">       * new Pcre object, match globally ("g" flag)</span>
<span class="comment">       */</span>
      <a class="code" href="classpcrepp_1_1Pcre.html#a0">Pcre</a> S(delimiter, <span class="stringliteral">"g"</span>);

      <span class="comment">/*</span>
<span class="comment">       * split "was21willst2387461du3alter!" by digits</span>
<span class="comment">       */</span>
      Array splitted = S.split(sp_orig);
      
      <span class="comment">/*</span>
<span class="comment">       * iterate over the resulting list</span>
<span class="comment">       */</span>
      cout &lt;&lt; <span class="stringliteral">"   splitted: "</span>;
      <span class="keywordflow">for</span>(ArrayIterator A = splitted.begin(); A != splitted.end(); ++A)
        cout &lt;&lt; *A &lt;&lt; <span class="stringliteral">" "</span>;
      cout &lt;&lt; endl;
}


<span class="keywordtype">void</span> ex() {
  <span class="comment">/*</span>
<span class="comment">   * Pcre::exception Test</span>
<span class="comment">   */</span>
  
  <span class="comment">/*</span>
<span class="comment">   * this will generate only one substring, "This"</span>
<span class="comment">   */</span>
  <a class="code" href="classpcrepp_1_1Pcre.html#a0">Pcre</a> ex(<span class="stringliteral">"([a-z]+)"</span>, <span class="stringliteral">"i"</span>);
  <span class="keywordflow">if</span>(ex.search(<span class="stringliteral">"This is a test."</span>)) {
    cout &lt;&lt; <span class="stringliteral">"  trying to access a non-existing substring:"</span> &lt;&lt; endl;
    cout &lt;&lt; <span class="stringliteral">"  substring 2: "</span> &lt;&lt; ex.get_match(1) &lt;&lt; endl; 
  }
}


<span class="keywordtype">void</span> mycopy() {
  <span class="comment">/*</span>
<span class="comment">   * Sample use of copy contsructor and operator=</span>
<span class="comment">   */</span>
    cout &lt;&lt; <span class="stringliteral">"  initializing reg1(([a-z]+?)"</span> &lt;&lt; endl;
    <a class="code" href="classpcrepp_1_1Pcre.html#a0">Pcre</a> reg1(<span class="stringliteral">"^([a-z]+?)"</span>);

    <span class="comment">/*</span>
<span class="comment">     * create an empty Pcre objects</span>
<span class="comment">     */</span>
    <a class="code" href="classpcrepp_1_1Pcre.html#a0">Pcre</a> reg2;
    
    <span class="comment">/*</span>
<span class="comment">     * copy reg1 to reg2 (operator=)</span>
<span class="comment">     */</span>
    cout &lt;&lt; <span class="stringliteral">"  copying reg1 to new Pcre object reg2"</span> &lt;&lt; endl;
    reg2 = reg1;

    <span class="comment">/*</span>
<span class="comment">     * using the copy constructor to initialize the 3rd object</span>
<span class="comment">     */</span>
    cout &lt;&lt; <span class="stringliteral">"  creating a new Pcre object reg3 from reg2"</span> &lt;&lt; endl;
    <a class="code" href="classpcrepp_1_1Pcre.html#a0">Pcre</a> reg3(reg2);

    <span class="comment">/*</span>
<span class="comment">     * doing regular stuff on reg3</span>
<span class="comment">     */</span>
    <span class="keywordflow">if</span>(reg3.search(<span class="stringliteral">"anton"</span>))
      cout &lt;&lt; <span class="stringliteral">"  string 'anton' matched using reg3 object"</span> &lt;&lt; endl;
}

<span class="keywordtype">void</span> multisearch() {
  <a class="code" href="classpcrepp_1_1Pcre.html#a0">Pcre</a> reg(<span class="stringliteral">"([^\\n]+\\n)"</span>);
  string str = <span class="stringliteral">"\nline1\nline2\nline3\n"</span>;
  size_t pos = 0;

  <span class="keywordflow">while</span> (pos &lt;= str.length()) {
    <span class="keywordflow">if</span>( reg.search(str, pos)) {
      pos = reg.get_match_end(0);
      cout &lt;&lt; <span class="stringliteral">"   pos: "</span> &lt;&lt; pos &lt;&lt; <span class="stringliteral">" match: "</span> &lt;&lt; reg.get_match(0);
    }
    <span class="keywordflow">else</span>
      <span class="keywordflow">break</span>;
  }
}

<span class="keywordtype">int</span> main() {
  <span class="comment">/* </span>
<span class="comment">   * the Pcre class throws errors via exceptions</span>
<span class="comment">   */</span>
  <span class="keywordflow">try</span> {
    cout &lt;&lt; endl &lt;&lt; <span class="stringliteral">"SEARCH() sample:"</span> &lt;&lt; endl;
    regex();

    cout &lt;&lt; endl &lt;&lt; <span class="stringliteral">"REPLACE() sample:"</span> &lt;&lt; endl;
    <a class="code" href="classpcrepp_1_1Pcre.html#a24">replace</a>();

    cout &lt;&lt; endl &lt;&lt; <span class="stringliteral">"Multiple REPLACE() sample:"</span> &lt;&lt; endl;
    replace_multi();

    cout &lt;&lt; endl &lt;&lt; <span class="stringliteral">"Normalizing REPLACE() sample:"</span> &lt;&lt; endl;
    normalize();

    cout &lt;&lt; endl &lt;&lt; <span class="stringliteral">"SPLIT() sample:"</span> &lt;&lt; endl;
    <a class="code" href="classpcrepp_1_1Pcre.html#a19">split</a>();

    cout &lt;&lt; endl &lt;&lt; <span class="stringliteral">"COPY+Operator sample:"</span> &lt;&lt; endl;
    mycopy();

    cout &lt;&lt; endl &lt;&lt; <span class="stringliteral">"Multi line search test:"</span> &lt;&lt; endl;
    multisearch();

    cout &lt;&lt; endl &lt;&lt; <span class="stringliteral">"Pcre::exception test:"</span> &lt;&lt; endl;
    ex();

    exit(0);
  }
  <span class="keywordflow">catch</span> (Pcre::exception &amp;E) {
    <span class="comment">/*</span>
<span class="comment">     * the Pcre class has thrown an exception</span>
<span class="comment">     */</span>
    cerr &lt;&lt; <span class="stringliteral">"Pcre++ error: "</span> &lt;&lt; E.what() &lt;&lt; endl;
    exit(-1);
  }
  exit(0);
}
  
</pre></div><p>
Compile your programs which use the prce++ class using the following command line: <div class="fragment"><pre>
   g++ -c yourcode.o `pcre-config --cflags` `pcre++-config --cflags`
   g++ yourcode.o `pcre-config --libs` `pcre++-config --libs` -o yourprogram
 
</pre></div><p>
If you want to learn more about regular expressions which can be used with pcre++, then please read the following documentation: <a href="perlre.html">perlre - Perl regular expressions</a><p>
The pcre library itself does also contain some usefull documentation, which maybe interesting for you: <a href="pcre.html">PCRE manual page</a> 
<p>

<p>
Definition at line <a class="el" href="pcre++_8h-source.html#l00099">99</a> of file <a class="el" href="pcre++_8h-source.html">pcre++.h</a>.<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a name="a0" doxytag="pcrepp::Pcre::Pcre"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> Pcre::Pcre </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Empty Constructor. Create a new empty <a class="el" href="classpcrepp_1_1Pcre.html">Pcre</a> object. This is the simplest constructor available, you might consider one of the other constructors as a better solution. You need to initialize thie <a class="el" href="classpcrepp_1_1Pcre.html">Pcre</a> object, if you use the empty constructor. You can use one of the two available operator= operators to assign it an expression or a <a class="el" href="classpcrepp_1_1Pcre.html">Pcre</a> copy.<p>
<dl compact><dt><b>Returns:</b></dt><dd>A new empty <a class="el" href="classpcrepp_1_1Pcre.html">Pcre</a> object </dd></dl>

<p>
Definition at line <a class="el" href="pcre++_8cc-source.html#l00107">107</a> of file <a class="el" href="pcre++_8cc-source.html">pcre++.cc</a>.    </td>
  </tr>
</table>
<a name="a1" doxytag="pcrepp::Pcre::Pcre"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> Pcre::Pcre </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const std::string &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>expression</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Constructor. Compile the given pattern. An <a class="el" href="classpcrepp_1_1Pcre.html">Pcre</a> object created this way can be used multiple times to do searches.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>expression</em>&nbsp;</td><td>a string, which must be a valid perl regular expression. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A new <a class="el" href="classpcrepp_1_1Pcre.html">Pcre</a> object, which holds te compiled pattern. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classpcrepp_1_1Pcre.html#a2">Pcre(const std::string&amp; expression, const std::string&amp; flags)</a> <p>
<a class="el" href="classpcrepp_1_1Pcre.html#a3">Pcre(const std::string&amp; expression, unsigned int flags)</a> </dd></dl>

<p>
Definition at line <a class="el" href="pcre++_8cc-source.html#l00050">50</a> of file <a class="el" href="pcre++_8cc-source.html">pcre++.cc</a>.    </td>
  </tr>
</table>
<a name="a2" doxytag="pcrepp::Pcre::Pcre"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> Pcre::Pcre </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const std::string &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>expression</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const std::string &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>flags</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Constructor. Compile the given pattern. An <a class="el" href="classpcrepp_1_1Pcre.html">Pcre</a> object created this way can be used multiple times to do searches.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>expression</em>&nbsp;</td><td>a string, which must be a valid perl regular expression. </td></tr>
    <tr><td valign=top><em>flags</em>&nbsp;</td><td>can be one or more of the following letters:</td></tr>
  </table>
</dl>
<ul>
<li><b>i</b> Search case insensitive.</li></ul>
<p>
<ul>
<li><b>m</b> Match on multiple lines, thus ^ and $ are interpreted as the start and end of the entire string, not of a single line.</li></ul>
<p>
<ul>
<li><b>s</b> A dot in an expression matches newlines too(which is normally not the case).</li></ul>
<p>
<ul>
<li><b>x</b> Whitespace characters will be ignored (except within character classes or if escaped).</li></ul>
<p>
<ul>
<li><b>g</b> Match multiple times. This flags affects only the behavior of the <a class="el" href="classpcrepp_1_1Pcre.html#a24">replace(const std::string&amp; piece, const std::string&amp; with)</a> method.</li></ul>
<p>
<dl compact><dt><b>Returns:</b></dt><dd>A new <a class="el" href="classpcrepp_1_1Pcre.html">Pcre</a> object, which holds te compiled pattern. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classpcrepp_1_1Pcre.html#a1">Pcre(const std::string&amp; expression)</a> <p>
<a class="el" href="classpcrepp_1_1Pcre.html#a3">Pcre(const std::string&amp; expression, unsigned int flags)</a> </dd></dl>

<p>
Definition at line <a class="el" href="pcre++_8cc-source.html#l00059">59</a> of file <a class="el" href="pcre++_8cc-source.html">pcre++.cc</a>.    </td>
  </tr>
</table>
<a name="a3" doxytag="pcrepp::Pcre::Pcre"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> Pcre::Pcre </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const std::string &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>expression</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>flags</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Constructor. Compile the given pattern. An <a class="el" href="classpcrepp_1_1Pcre.html">Pcre</a> object created this way can be used multiple times to do searches.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>expression</em>&nbsp;</td><td>a string, which must be a valid perl regular expression. </td></tr>
    <tr><td valign=top><em>flags</em>&nbsp;</td><td>option bits can be one or more of the following bits:</td></tr>
  </table>
</dl>
<ul>
<li>PCRE_ANCHORED anchored pattern.</li><li>PCRE_CASELESS case insensitive search.</li><li>PCRE_DOLLAR_ENDONLY dollar sign matches only at end.</li><li>PCRE_DOTALL newline is contained in .</li><li>PCRE_EXTENDED whitespace characters will be ignored.</li><li>PCRE_EXTRA use perl incompatible pcre extensions.</li><li>PCRE_MULTILINE match on multiple lines.</li><li>PCRE_NO_AUTO_CAPTURE disable the use of numbered capturing parentheses in the pattern.</li><li>PCRE_UNGREEDY qunatifiers behave not greedy by default.</li><li>PCRE_UTF8 use utf8 support.</li><li>PCRE_GLOBAL (PCRE++ internal flag) match multiple times used only in the <a class="el" href="classpcrepp_1_1Pcre.html#a24">replace(const std::string&amp; piece, const std::string&amp; with)</a> method.</li></ul>
<p>
<dl compact><dt><b>Returns:</b></dt><dd>A new <a class="el" href="classpcrepp_1_1Pcre.html">Pcre</a> object, which holds te compiled pattern. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classpcrepp_1_1Pcre.html#a1">Pcre(const std::string&amp; expression)</a> <p>
<a class="el" href="classpcrepp_1_1Pcre.html#a2">Pcre(const std::string&amp; expression, const std::string&amp; flags)</a> <p>
pcreapi(3) manpage </dd></dl>

<p>
Definition at line <a class="el" href="pcre++_8cc-source.html#l00080">80</a> of file <a class="el" href="pcre++_8cc-source.html">pcre++.cc</a>.
<p>
References <a class="el" href="pcre++_8h-source.html#l00068">PCRE_GLOBAL</a>.    </td>
  </tr>
</table>
<a name="a4" doxytag="pcrepp::Pcre::Pcre"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> Pcre::Pcre </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const Pcre &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>P</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Copy Constructor Creates a new <a class="el" href="classpcrepp_1_1Pcre.html">Pcre</a> object of an existing one. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>P</em>&nbsp;</td><td>an existing <a class="el" href="classpcrepp_1_1Pcre.html">Pcre</a> object. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A new <a class="el" href="classpcrepp_1_1Pcre.html">Pcre</a> object, which holds te compiled pattern. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classpcrepp_1_1Pcre.html#a1">Pcre(const std::string&amp; expression)</a> <p>
<a class="el" href="classpcrepp_1_1Pcre.html#a2">Pcre(const std::string&amp; expression, const std::string&amp; flags)</a> </dd></dl>

<p>
Definition at line <a class="el" href="pcre++_8cc-source.html#l00097">97</a> of file <a class="el" href="pcre++_8cc-source.html">pcre++.cc</a>.
<p>
References <a class="el" href="pcre++_8h-source.html#l00101">_expression</a>, <a class="el" href="pcre++_8h-source.html#l00102">_flags</a>, <a class="el" href="pcre++_8h-source.html#l00111">_have_paren</a>, <a class="el" href="pcre++_8h-source.html#l00103">case_t</a>, and <a class="el" href="pcre++_8h-source.html#l00103">global_t</a>.    </td>
  </tr>
</table>
<a name="a7" doxytag="pcrepp::Pcre::~Pcre"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> Pcre::~Pcre </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Destructor. The desturcor will automatically invoked if the object is no more used. It frees all the memory allocated by pcre++. 
<p>
Definition at line <a class="el" href="pcre++_8cc-source.html#l00120">120</a> of file <a class="el" href="pcre++_8cc-source.html">pcre++.cc</a>.    </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a name="a11" doxytag="pcrepp::Pcre::get_match"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> string Pcre::get_match </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>pos</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get a substring at a known position. This method throws an out-of-range exception if the given position is invalid. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>pos</em>&nbsp;</td><td>the position of the substring to return. Identical to perl's $1..$n. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the substring at the given position.</dd></dl>
Example: <div class="fragment"><pre>
 
 std::string mysub = regex.get_match(1); 
 
 
</pre></div>Get the first substring that matched the expression in the "regex" object. 
<p>
Definition at line <a class="el" href="get_8cc-source.html#l00060">60</a> of file <a class="el" href="get_8cc-source.html">get.cc</a>.
<p>
Referenced by <a class="el" href="pcre++_8h-source.html#l00594">operator[]()</a>.    </td>
  </tr>
</table>
<a name="a15" doxytag="pcrepp::Pcre::get_match_end"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int Pcre::get_match_end </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the end position of the entire match within the searched string. This method returns the character position of the last character of the entire match within the searched string. <dl compact><dt><b>Returns:</b></dt><dd>the integer character position of the last character of the entire match.</dd></dl>
Example: <div class="fragment"><pre>

 <a class="code" href="classpcrepp_1_1Pcre.html#a0">Pcre</a> regex(<span class="stringliteral">"([0-9]+)\s([a-z]+)"</span>);     <span class="comment">// search for the date(makes 2 substrings</span>
 regex.search(<span class="stringliteral">"The 11th september."</span>);  <span class="comment">// do the search on this string</span>
 <span class="keywordtype">int</span> pos = regex.get_match_end();      <span class="comment">// returns 17, because "11th september", which is</span>
                                           <span class="comment">// the entire match, ends at the</span>
                                       <span class="comment">// 17th character inside the search string.</span>

 
</pre></div><dl compact><dt><b>See also:</b></dt><dd>int <a class="el" href="classpcrepp_1_1Pcre.html#a12">get_match_start()</a> <p>
int get_match_start(int pos) <p>
int get_match_end(int pos) </dd></dl>

<p>
Definition at line <a class="el" href="get_8cc-source.html#l00077">77</a> of file <a class="el" href="get_8cc-source.html">get.cc</a>.
<p>
Referenced by <a class="el" href="replace_8cc-source.html#l00051">replace()</a>.    </td>
  </tr>
</table>
<a name="a13" doxytag="pcrepp::Pcre::get_match_end"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int Pcre::get_match_end </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>pos</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the end position of a substring within the searched string. This method returns the character position of the last character of a substring withing the searched string. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>pos</em>&nbsp;</td><td>the position of the substring. Identical to perl's $1..$n. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the integer character position of the last character of a substring. Positions are starting at 0.</dd></dl>
Example: <div class="fragment"><pre>

 <a class="code" href="classpcrepp_1_1Pcre.html#a0">Pcre</a> regex(<span class="stringliteral">"([0-9]+)"</span>);               <span class="comment">// search for numerical characters</span>
 regex.search(<span class="stringliteral">"The 11th september."</span>);  <span class="comment">// do the search on this string</span>
 std::string day = regex.get_match(1);      <span class="comment">// returns "11"</span>
 <span class="keywordtype">int</span> pos = regex.get_match_end(1);     <span class="comment">// returns 5, because "11" ends at the</span>
                                       <span class="comment">// 5th character inside the search string.</span>

 
</pre></div><dl compact><dt><b>See also:</b></dt><dd>int get_match_start(int pos) <p>
int <a class="el" href="classpcrepp_1_1Pcre.html#a12">get_match_start()</a> <p>
int <a class="el" href="classpcrepp_1_1Pcre.html#a13">get_match_end()</a> </dd></dl>

<p>
Definition at line <a class="el" href="get_8cc-source.html#l00096">96</a> of file <a class="el" href="get_8cc-source.html">get.cc</a>.    </td>
  </tr>
</table>
<a name="a16" doxytag="pcrepp::Pcre::get_match_length"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> size_t Pcre::get_match_length </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>pos</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the length of a substring at a known position. This method throws an out-of-range exception if the given position is invalid. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>pos</em>&nbsp;</td><td>the position of the substring-length to return. Identical to perl's $1..$n. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the length substring at the given position. </dd></dl>

<p>
Definition at line <a class="el" href="get_8cc-source.html#l00110">110</a> of file <a class="el" href="get_8cc-source.html">get.cc</a>.    </td>
  </tr>
</table>
<a name="a14" doxytag="pcrepp::Pcre::get_match_start"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int Pcre::get_match_start </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the start position of the entire match within the searched string. This method returns the character position of the first character of the entire match within the searched string. <dl compact><dt><b>Returns:</b></dt><dd>the integer character position of the first character of the entire match.</dd></dl>
Example: <div class="fragment"><pre>

 <a class="code" href="classpcrepp_1_1Pcre.html#a0">Pcre</a> regex(<span class="stringliteral">"([0-9]+)\s([a-z]+)"</span>);     <span class="comment">// search for the date(makes 2 substrings</span>
 regex.search(<span class="stringliteral">"The 11th september."</span>);  <span class="comment">// do the search on this string</span>
 <span class="keywordtype">int</span> pos = regex.get_match_start();    <span class="comment">// returns 4, because "11th september" begins at the</span>
                                       <span class="comment">// 4th character inside the search string.</span>

 
</pre></div><dl compact><dt><b>See also:</b></dt><dd>int get_match_start(int pos) <p>
int get_match_end(int pos) <p>
int <a class="el" href="classpcrepp_1_1Pcre.html#a13">get_match_end()</a> </dd></dl>

<p>
Definition at line <a class="el" href="get_8cc-source.html#l00070">70</a> of file <a class="el" href="get_8cc-source.html">get.cc</a>.
<p>
Referenced by <a class="el" href="replace_8cc-source.html#l00051">replace()</a>.    </td>
  </tr>
</table>
<a name="a12" doxytag="pcrepp::Pcre::get_match_start"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int Pcre::get_match_start </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>pos</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the start position of a substring within the searched string. This method returns the character position of the first character of a substring withing the searched string. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>pos</em>&nbsp;</td><td>the position of the substring. Identical to perl's $1..$n. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the integer character position of the first character of a substring. Positions are starting at 0.</dd></dl>
Example: <div class="fragment"><pre>
 
 <a class="code" href="classpcrepp_1_1Pcre.html#a0">Pcre</a> regex(<span class="stringliteral">"([0-9]+)"</span>);               <span class="comment">// search for numerical characters</span>
 regex.search(<span class="stringliteral">"The 11th september."</span>);  <span class="comment">// do the search on this string</span>
 std::string day = regex.get_match(1);      <span class="comment">// returns "11"</span>
 <span class="keywordtype">int</span> pos = regex.get_match_start(1);   <span class="comment">// returns 4, because "11" begins at the</span>
                                       <span class="comment">// 4th character inside the search string.</span>

 
</pre></div><dl compact><dt><b>See also:</b></dt><dd>int get_match_end(int pos) <p>
int <a class="el" href="classpcrepp_1_1Pcre.html#a13">get_match_end()</a> <p>
int <a class="el" href="classpcrepp_1_1Pcre.html#a12">get_match_start()</a> </dd></dl>

<p>
Definition at line <a class="el" href="get_8cc-source.html#l00084">84</a> of file <a class="el" href="get_8cc-source.html">get.cc</a>.    </td>
  </tr>
</table>
<a name="a25" doxytag="pcrepp::Pcre::get_pcre"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> pcre * Pcre::get_pcre </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return pointer to underlying pcre object. The pcre object allows you to access the pcre API directly. E.g. if your are using pcre version 4.x and want to use the new functionality which is currently not supported by pcre++. An example would be: pcre_fullinfo(), pcre_study() or the callout functionality.<p>
<dl compact><dt><b>Returns:</b></dt><dd>"pcre*" pointer to pcre object. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd>man pcre <p>
pcre_extra* <a class="el" href="classpcrepp_1_1Pcre.html#a26">get_pcre_extra()</a> </dd></dl>

<p>
Definition at line <a class="el" href="pcre++_8cc-source.html#l00195">195</a> of file <a class="el" href="pcre++_8cc-source.html">pcre++.cc</a>.    </td>
  </tr>
</table>
<a name="a26" doxytag="pcrepp::Pcre::get_pcre_extra"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> pcre_extra * Pcre::get_pcre_extra </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return pointer to underlying pcre_extra structure. The returned pcre_extra structure can be used in conjunction with the pcre* object returned by pcre().<p>
<dl compact><dt><b>Returns:</b></dt><dd>"pcre_extra*" pointer to pcre_extra structure. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd>pcre* <a class="el" href="classpcrepp_1_1Pcre.html#a25">get_pcre()</a> </dd></dl>

<p>
Definition at line <a class="el" href="pcre++_8cc-source.html#l00199">199</a> of file <a class="el" href="pcre++_8cc-source.html">pcre++.cc</a>.    </td>
  </tr>
</table>
<a name="a10" doxytag="pcrepp::Pcre::get_sub_strings"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> vector&lt; string &gt; * Pcre::get_sub_strings </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return a vector of substrings, if any. <dl compact><dt><b>Returns:</b></dt><dd>a pointer to an std::vector&lt;std::string&gt;, which may be NULL, if no substrings has been found. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd>std::vector&lt;std::string&gt; </dd></dl>

<p>
Definition at line <a class="el" href="get_8cc-source.html#l00053">53</a> of file <a class="el" href="get_8cc-source.html">get.cc</a>.    </td>
  </tr>
</table>
<a name="a17" doxytag="pcrepp::Pcre::matched"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> bool pcrepp::Pcre::matched </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Test if a search was successfull. This method must be invoked <b>after</b> calling <a class="el" href="classpcrepp_1_1Pcre.html#a8">search()</a>. <dl compact><dt><b>Returns:</b></dt><dd>boolean <b>true</b> if the search was successfull at all, or <b>false</b> if not. </dd></dl>

<p>
Definition at line <a class="el" href="pcre++_8h-source.html#l00444">444</a> of file <a class="el" href="pcre++_8h-source.html">pcre++.h</a>.
<p>
Referenced by <a class="el" href="replace_8cc-source.html#l00051">replace()</a>.    </td>
  </tr>
</table>
<a name="a18" doxytag="pcrepp::Pcre::matches"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int pcrepp::Pcre::matches </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the number of substrings generated by pcre++. <dl compact><dt><b>Returns:</b></dt><dd>the number of substrings generated by pcre++. </dd></dl>

<p>
Definition at line <a class="el" href="pcre++_8h-source.html#l00449">449</a> of file <a class="el" href="pcre++_8h-source.html">pcre++.h</a>.
<p>
Referenced by <a class="el" href="replace_8cc-source.html#l00051">replace()</a>.    </td>
  </tr>
</table>
<a name="a6" doxytag="pcrepp::Pcre::operator="></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> const Pcre &amp; Pcre::operator= </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const Pcre &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>P</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Operator =. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>&amp;P</em>&nbsp;</td><td>an <a class="el" href="classpcrepp_1_1Pcre.html">Pcre</a> object </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>a new <a class="el" href="classpcrepp_1_1Pcre.html">Pcre</a> object</dd></dl>
Example:<p>
<div class="fragment"><pre>
 <a class="code" href="classpcrepp_1_1Pcre.html#a0">Pcre</a> reg1(<span class="stringliteral">"^[a-z]+?"</span>);
 <a class="code" href="classpcrepp_1_1Pcre.html#a0">Pcre</a> reg2;
 reg2 = reg1;
 
</pre></div>
<p>
Definition at line <a class="el" href="pcre++_8cc-source.html#l00153">153</a> of file <a class="el" href="pcre++_8cc-source.html">pcre++.cc</a>.
<p>
References <a class="el" href="pcre++_8h-source.html#l00101">_expression</a>, <a class="el" href="pcre++_8h-source.html#l00102">_flags</a>, <a class="el" href="pcre++_8h-source.html#l00103">case_t</a>, and <a class="el" href="pcre++_8h-source.html#l00103">global_t</a>.    </td>
  </tr>
</table>
<a name="a5" doxytag="pcrepp::Pcre::operator="></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> const Pcre &amp; Pcre::operator= </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const std::string &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>expression</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Operator =. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>expression</em>&nbsp;</td><td>a valid regular expression. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>a new <a class="el" href="classpcrepp_1_1Pcre.html">Pcre</a> object.</dd></dl>
Example:<p>
<div class="fragment"><pre>
 <a class="code" href="classpcrepp_1_1Pcre.html#a0">Pcre</a> regex = <span class="stringliteral">"(A+?)"</span>;
 
</pre></div>
<p>
Definition at line <a class="el" href="pcre++_8cc-source.html#l00142">142</a> of file <a class="el" href="pcre++_8cc-source.html">pcre++.cc</a>.    </td>
  </tr>
</table>
<a name="a29" doxytag="pcrepp::Pcre::operator[]"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> std::string pcrepp::Pcre::operator[] </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>index</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return substring of a match at a known possition using the array notation. This method throws an out-of-range exception if the given position is invalid. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>index</em>&nbsp;</td><td>the position of the substring to return. Identical to perl's $1..$n. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the substring at the given position.</dd></dl>
Example: <div class="fragment"><pre>
 
 std::string mysub = regex[1]; 
 
 
</pre></div>Get the first substring that matched the expression in the "regex" object.<p>
<dl compact><dt><b>See also:</b></dt><dd>std::string get_match(int pos) </dd></dl>

<p>
Definition at line <a class="el" href="pcre++_8h-source.html#l00594">594</a> of file <a class="el" href="pcre++_8h-source.html">pcre++.h</a>.
<p>
References <a class="el" href="get_8cc-source.html#l00060">get_match()</a>.    </td>
  </tr>
</table>
<a name="a24" doxytag="pcrepp::Pcre::replace"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> string Pcre::replace </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const std::string &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>piece</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const std::string &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>with</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Replace parts of a string using regular expressions. This method is the counterpart of the perl s/// operator. It replaces the substrings which matched the given regular expression (given to the constructor) with the supplied string.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>piece</em>&nbsp;</td><td>the string in which you want to search and replace. </td></tr>
    <tr><td valign=top><em>with</em>&nbsp;</td><td>the string which you want to place on the positions which match the expression (given to the constructor). </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="replace_8cc-source.html#l00051">51</a> of file <a class="el" href="replace_8cc-source.html">replace.cc</a>.
<p>
References <a class="el" href="pcre++_8h-source.html#l00062">__pcredebug</a>, <a class="el" href="get_8cc-source.html#l00077">get_match_end()</a>, <a class="el" href="get_8cc-source.html#l00070">get_match_start()</a>, <a class="el" href="pcre++_8h-source.html#l00444">matched()</a>, <a class="el" href="pcre++_8h-source.html#l00449">matches()</a>, and <a class="el" href="search_8cc-source.html#l00087">search()</a>.    </td>
  </tr>
</table>
<a name="a9" doxytag="pcrepp::Pcre::search"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> bool Pcre::search </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const std::string &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>stuff</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>OffSet</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Do a search on the given string beginning at the given offset. This method does the actual search on the given string. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>stuff</em>&nbsp;</td><td>the string in which you want to search for something. </td></tr>
    <tr><td valign=top><em>OffSet</em>&nbsp;</td><td>the offset where to start the search. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>boolean <b>true</b> if the regular expression matched. <b>false</b> if not. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd>bool <a class="el" href="classpcrepp_1_1Pcre.html#a8">search(const std::string&amp; stuff)</a> </dd></dl>

<p>
Definition at line <a class="el" href="search_8cc-source.html#l00083">83</a> of file <a class="el" href="search_8cc-source.html">search.cc</a>.    </td>
  </tr>
</table>
<a name="a8" doxytag="pcrepp::Pcre::search"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> bool Pcre::search </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const std::string &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>stuff</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Do a search on the given string. This method does the actual search on the given string. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>stuff</em>&nbsp;</td><td>the string in which you want to search for something. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>boolean <b>true</b> if the regular expression matched. <b>false</b> if not. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd>bool <a class="el" href="classpcrepp_1_1Pcre.html#a9">search(const std::string&amp; stuff, int OffSet)</a> </dd></dl>

<p>
Definition at line <a class="el" href="search_8cc-source.html#l00087">87</a> of file <a class="el" href="search_8cc-source.html">search.cc</a>.
<p>
Referenced by <a class="el" href="replace_8cc-source.html#l00051">replace()</a>.    </td>
  </tr>
</table>
<a name="a28" doxytag="pcrepp::Pcre::setlocale"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> bool Pcre::setlocale </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>locale</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets locale for all character operations Returns false if locale can't be set. Otherwise returns true <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>locale</em>&nbsp;</td><td>locale alias name you want to use. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>true if setting locale were successful</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd>locale(1) </dd></dl>

<p>
Definition at line <a class="el" href="pcre++_8cc-source.html#l00220">220</a> of file <a class="el" href="pcre++_8cc-source.html">pcre++.cc</a>.    </td>
  </tr>
</table>
<a name="a23" doxytag="pcrepp::Pcre::split"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> vector&lt; string &gt; Pcre::split </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const std::string &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>piece</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>std::vector&lt; int &gt;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>positions</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
split a string into pieces This method will split the given string into a vector of strings using the compiled expression (given to the constructor).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>piece</em>&nbsp;</td><td>The string you want to split into it's parts. </td></tr>
    <tr><td valign=top><em>positions</em>&nbsp;</td><td>a std::vector&lt;int&gt; of positions, which the returned vector should contain. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>an vector of strings </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd>std::vector&lt;std::string&gt; <a class="el" href="classpcrepp_1_1Pcre.html#a19">split(const std::string&amp; piece)</a> <p>
std::vector&lt;std::string&gt; <a class="el" href="classpcrepp_1_1Pcre.html#a20">split(const std::string&amp; piece, int limit)</a> <p>
std::vector&lt;std::string&gt; <a class="el" href="classpcrepp_1_1Pcre.html#a21">split(const std::string&amp; piece, int limit, int start_offset)</a> <p>
std::vector&lt;std::string&gt; <a class="el" href="classpcrepp_1_1Pcre.html#a21">split(const std::string&amp; piece, int limit, int start_offset)</a> <p>
std::vector&lt;std::string&gt; </dd></dl>

<p>
Definition at line <a class="el" href="split_8cc-source.html#l00151">151</a> of file <a class="el" href="split_8cc-source.html">split.cc</a>.    </td>
  </tr>
</table>
<a name="a22" doxytag="pcrepp::Pcre::split"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> vector&lt; string &gt; Pcre::split </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const std::string &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>piece</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>limit</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>start_offset</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>end_offset</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
split a string into pieces This method will split the given string into a vector of strings using the compiled expression (given to the constructor).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>piece</em>&nbsp;</td><td>The string you want to split into it's parts. </td></tr>
    <tr><td valign=top><em>limit</em>&nbsp;</td><td>the maximum number of elements you want to get back from <a class="el" href="classpcrepp_1_1Pcre.html#a19">split()</a>. </td></tr>
    <tr><td valign=top><em>start_offset</em>&nbsp;</td><td>at which substring the returned vector should start. </td></tr>
    <tr><td valign=top><em>end_offset</em>&nbsp;</td><td>at which substring the returned vector should end. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>an vector of strings </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd>std::vector&lt;std::string&gt; <a class="el" href="classpcrepp_1_1Pcre.html#a19">split(const std::string&amp; piece)</a> <p>
std::vector&lt;std::string&gt; <a class="el" href="classpcrepp_1_1Pcre.html#a20">split(const std::string&amp; piece, int limit)</a> <p>
std::vector&lt;std::string&gt; <a class="el" href="classpcrepp_1_1Pcre.html#a21">split(const std::string&amp; piece, int limit, int start_offset)</a> <p>
std::vector&lt;std::string&gt; <a class="el" href="classpcrepp_1_1Pcre.html#a23">split(const std::string&amp; piece, std::vector&lt;int&gt; positions)</a> <p>
std::vector&lt;std::string&gt; </dd></dl>

<p>
Definition at line <a class="el" href="split_8cc-source.html#l00147">147</a> of file <a class="el" href="split_8cc-source.html">split.cc</a>.    </td>
  </tr>
</table>
<a name="a21" doxytag="pcrepp::Pcre::split"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> vector&lt; string &gt; Pcre::split </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const std::string &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>piece</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>limit</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>start_offset</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
split a string into pieces This method will split the given string into a vector of strings using the compiled expression (given to the constructor).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>piece</em>&nbsp;</td><td>The string you want to split into it's parts. </td></tr>
    <tr><td valign=top><em>limit</em>&nbsp;</td><td>the maximum number of elements you want to get back from <a class="el" href="classpcrepp_1_1Pcre.html#a19">split()</a>. </td></tr>
    <tr><td valign=top><em>start_offset</em>&nbsp;</td><td>at which substring the returned vector should start. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>an vector of strings </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd>std::vector&lt;std::string&gt; <p>
std::vector&lt;std::string&gt; <a class="el" href="classpcrepp_1_1Pcre.html#a19">split(const std::string&amp; piece)</a> <p>
std::vector&lt;std::string&gt; <a class="el" href="classpcrepp_1_1Pcre.html#a20">split(const std::string&amp; piece, int limit)</a> <p>
std::vector&lt;std::string&gt; <a class="el" href="classpcrepp_1_1Pcre.html#a22">split(const std::string&amp; piece, int limit, int start_offset, int end_offset)</a> <p>
std::vector&lt;std::string&gt; <a class="el" href="classpcrepp_1_1Pcre.html#a23">split(const std::string&amp; piece, std::vector&lt;int&gt; positions)</a> </dd></dl>

<p>
Definition at line <a class="el" href="split_8cc-source.html#l00143">143</a> of file <a class="el" href="split_8cc-source.html">split.cc</a>.    </td>
  </tr>
</table>
<a name="a20" doxytag="pcrepp::Pcre::split"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> vector&lt; string &gt; Pcre::split </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const std::string &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>piece</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>limit</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
split a string into pieces This method will split the given string into a vector of strings using the compiled expression (given to the constructor).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>piece</em>&nbsp;</td><td>The string you want to split into it's parts. </td></tr>
    <tr><td valign=top><em>limit</em>&nbsp;</td><td>the maximum number of elements you want to get back from <a class="el" href="classpcrepp_1_1Pcre.html#a19">split()</a>. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>an vector of strings </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd>std::vector&lt;std::string&gt; <p>
std::vector&lt;std::string&gt; <a class="el" href="classpcrepp_1_1Pcre.html#a19">split(const std::string&amp; piece)</a> <p>
std::vector&lt;std::string&gt; <a class="el" href="classpcrepp_1_1Pcre.html#a21">split(const std::string&amp; piece, int limit, int start_offset)</a> <p>
std::vector&lt;std::string&gt; <a class="el" href="classpcrepp_1_1Pcre.html#a22">split(const std::string&amp; piece, int limit, int start_offset, int end_offset)</a> <p>
std::vector&lt;std::string&gt; <a class="el" href="classpcrepp_1_1Pcre.html#a23">split(const std::string&amp; piece, std::vector&lt;int&gt; positions)</a> </dd></dl>

<p>
Definition at line <a class="el" href="split_8cc-source.html#l00139">139</a> of file <a class="el" href="split_8cc-source.html">split.cc</a>.    </td>
  </tr>
</table>
<a name="a19" doxytag="pcrepp::Pcre::split"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> vector&lt; string &gt; Pcre::split </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const std::string &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>piece</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
split a string into pieces This method will split the given string into a vector of strings using the compiled expression (given to the constructor).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>piece</em>&nbsp;</td><td>The string you want to split into it's parts. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>an vector of strings </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd>std::vector&lt;std::string&gt; <p>
std::vector&lt;std::string&gt; <a class="el" href="classpcrepp_1_1Pcre.html#a20">split(const std::string&amp; piece, int limit)</a> <p>
std::vector&lt;std::string&gt; <a class="el" href="classpcrepp_1_1Pcre.html#a21">split(const std::string&amp; piece, int limit, int start_offset)</a> <p>
std::vector&lt;std::string&gt; <a class="el" href="classpcrepp_1_1Pcre.html#a22">split(const std::string&amp; piece, int limit, int start_offset, int end_offset)</a> <p>
std::vector&lt;std::string&gt; <a class="el" href="classpcrepp_1_1Pcre.html#a23">split(const std::string&amp; piece, std::vector&lt;int&gt; positions)</a> </dd></dl>

<p>
Definition at line <a class="el" href="split_8cc-source.html#l00135">135</a> of file <a class="el" href="split_8cc-source.html">split.cc</a>.    </td>
  </tr>
</table>
<a name="a27" doxytag="pcrepp::Pcre::study"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void Pcre::study </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Analyze pattern for speeding up the matching process. When a pattern is going to be used several times, it is worth spending more time analyzing it in order to speed up the time taken for matching.<p>
An excpetion will be thrown if analyzing the pattern failed. 
<p>
Definition at line <a class="el" href="pcre++_8cc-source.html#l00210">210</a> of file <a class="el" href="pcre++_8cc-source.html">pcre++.cc</a>.    </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="pcre++_8h-source.html">pcre++.h</a><li><a class="el" href="pcre++_8cc-source.html">pcre++.cc</a><li><a class="el" href="replace_8cc-source.html">replace.cc</a><li><a class="el" href="search_8cc-source.html">search.cc</a><li><a class="el" href="split_8cc-source.html">split.cc</a><li><a class="el" href="get_8cc-source.html">get.cc</a></ul>
<hr><address style="align: right;"><small>Generated on Wed Aug 25 01:38:04 2004 for PCRE++ by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.3-rc3 </small></address>
</body>
</html>
